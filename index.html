<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO - Professional Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: #1a5e34;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)),
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%231a5e34"/><path d="M0 0L100 100M100 0L0 100" stroke="%23147d3c" stroke-width="1"/></svg>');
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            border: 2px solid #ffde59;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            color: #ffde59;
            text-shadow: 3px 3px 0 #000;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #fff;
        }

        /* Setup Screen */
        .setup-screen {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 20px;
            text-align: center;
            border: 2px solid #ffde59;
        }

        .player-setup {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }

        .player-option {
            background: #2d7d46;
            border-radius: 10px;
            padding: 15px;
            width: 200px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .player-option:hover {
            background: #3d9d56;
            transform: translateY(-5px);
        }

        .player-option.selected {
            background: #ffde59;
            border: 2px solid #000;
            color: #000;
        }

        .option-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: bold;
            border: 3px solid #000;
            background: #fff;
            color: #000;
        }

        .option-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .option-gender {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        /* Game Area */
        .game-area {
            display: none;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }

        .players-container {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .player {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .player.active {
            background: rgba(255, 222, 89, 0.2);
            transform: scale(1.03);
            border: 2px solid #ffde59;
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 3px solid #fff;
            background: #2d7d46;
            color: #fff;
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .player-cards {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .card-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.9rem;
        }

        .game-board {
            flex: 2;
            min-width: 500px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid #ffde59;
        }

        .deck-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin: 20px 0;
            width: 100%;
        }

        .deck,
        .discard-pile {
            width: 120px;
            height: 170px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition: transform 0.2s;
            border: 2px solid #000;
            position: relative;
            overflow: hidden;
        }

        .deck {
            background: #2d7d46;
            color: #fff;
            font-weight: bold;
            background-image:
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.2) 0%, transparent 20%),
                radial-gradient(circle at 70% 70%, rgba(255, 255, 255, 0.1) 0%, transparent 20%);
        }

        .deck::before {
            content: "UNO";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .discard-pile {
            background: #fff;
            color: #000;
            font-weight: bold;
            position: relative;
        }

        .discard-pile .current-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .discard-pile .current-card::before {
            content: "";
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .discard-pile .card-corner {
            position: absolute;
            font-size: 1rem;
            font-weight: bold;
            z-index: 1;
        }

        .discard-pile .card-corner.top-left {
            top: 5px;
            left: 8px;
        }

        .discard-pile .card-corner.bottom-right {
            bottom: 5px;
            right: 8px;
            transform: rotate(180deg);
        }

        .discard-pile .card-center {
            font-size: 2.5rem;
            font-weight: bold;
            z-index: 1;
        }

        .deck:hover {
            transform: scale(1.05);
        }

        .current-card {
            font-size: 2.5rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            background: #ffde59;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 2px solid #000;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: #ffed9e;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.5;
            color: #ccc;
        }

        .hand {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            min-height: 180px;
        }

        .card {
            width: 90px;
            height: 130px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
            position: relative;
            border: 2px solid #000;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-10px);
        }

        .card.red {
            background: #e74c3c;
            color: white;
        }

        .card.blue {
            background: #3498db;
            color: white;
        }

        .card.green {
            background: #2ecc71;
            color: white;
        }

        .card.yellow {
            background: #f1c40f;
            color: #000;
        }

        .card.wild {
            background: #656565;
            color: white;
        }

        .wild {
            background: #656565;
            color: white;
        }

        .card::before {
            content: "";
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .card-corner {
            position: absolute;
            font-size: 1rem;
            font-weight: bold;
            z-index: 1;
        }

        .card-corner.top-left {
            top: 5px;
            left: 8px;
        }

        .card-corner.bottom-right {
            bottom: 5px;
            right: 8px;
            transform: rotate(180deg);
        }

        .card-center {
            font-size: 2.5rem;
            font-weight: bold;
            z-index: 1;
        }

        .message-area {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            min-height: 80px;
            width: 100%;
            text-align: center;
            font-size: 1.1rem;
            border: 1px solid #ffde59;
        }

        .chat-area {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ffde59;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        .chat-message.player {
            background: rgba(255, 222, 89, 0.3);
            text-align: right;
        }

        .chat-message.npc {
            background: rgba(52, 152, 219, 0.3);
        }

        .body-swap-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .swap-content {
            background: #1a5e34;
            color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            animation: pulse 1s infinite;
            border: 3px solid #ffde59;
            box-shadow: 0 0 30px rgba(255, 222, 89, 0.5);
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 222, 89, 0.5);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 0 40px rgba(255, 222, 89, 0.7);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 222, 89, 0.5);
            }
        }

        .swap-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #ffde59;
            text-shadow: 2px 2px 0 #000;
        }

        .swap-players {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
        }

        .swap-player {
            text-align: center;
        }

        .swap-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            margin: 0 auto 10px;
            border: 4px solid #ffde59;
            background: #2d7d46;
            color: #fff;
        }

        .color-selection {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 10px 0;
        }

        .color-option {
            width: 60px;
            height: 90px;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .color-option::before {
            content: "";
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .color-option:hover {
            transform: scale(1.1);
            border: 2px solid #ffde59;
        }

        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .card.wild .card-center {
            font-size: 1.8rem;
            /* Smaller font for SWAP text */
        }

        .color-option.wild {
            background: #000;
            color: white;
        }

        .game-over-content {
            background: #1a5e34;
            color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 600px;
            border: 3px solid #ffde59;
            box-shadow: 0 0 30px rgba(255, 222, 89, 0.5);
        }

        .game-over-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #ffde59;
            text-shadow: 2px 2px 0 #000;
        }

        .player-identity {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            align-items: center;
        }

        .player-identity-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 2px solid #fff;
        }

        .uno-call {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #ffde59;
            color: #000;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            border: 2px solid #000;
            z-index: 10;
            display: none;
        }

        .red {
            background: #e74c3c;
            color: white;
        }

        .blue {
            background: #3498db;
            color: white;
        }

        .green {
            background: #2ecc71;
            color: white;
        }

        .yellow {
            background: #f1c40f;
            color: #000;
        }

        /* .wild .card-center{
            font-size:15px;
        } */
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
            }

            .game-board {
                min-width: 100%;
            }

            .card {
                width: 70px;
                height: 100px;
                font-size: 1.5rem;
            }

            .card-corner {
                font-size: 0.8rem;
            }

            .card-center {
                font-size: 2rem;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>UNO BODY SWAP</h1>
            <p class="subtitle">Classic Uno gameplay with a twist</p>
        </header>

        <!-- Setup Screen -->
        <div class="setup-screen" id="setup-screen">
            <h2>Choose Your Character</h2>
            <p>Select which player you want to be in the game</p>

            <div class="player-setup">
                <div class="player-option" data-player="0">
                    <div class="option-avatar" style="background-color: #e74c3c;">P1</div>
                    <div class="option-name">Alex</div>
                    <div class="option-gender">Male</div>
                    <div class="option-desc">The Strategist</div>
                </div>

                <div class="player-option" data-player="1">
                    <div class="option-avatar" style="background-color: #3498db;">P2</div>
                    <div class="option-name">Sam</div>
                    <div class="option-gender">Female</div>
                    <div class="option-desc">The Trickster</div>
                </div>

                <div class="player-option" data-player="2">
                    <div class="option-avatar" style="background-color: #2ecc71;">P3</div>
                    <div class="option-name">Jordan</div>
                    <div class="option-gender">Male</div>
                    <div class="option-desc">The Wild Card</div>
                </div>

                <div class="player-option" data-player="3">
                    <div class="option-avatar" style="background-color: #f1c40f; color: #000;">P4</div>
                    <div class="option-name">Taylor</div>
                    <div class="option-gender">Female</div>
                    <div class="option-desc">The Collector</div>
                </div>
            </div>

            <button id="start-game-btn">Start Game</button>
        </div>

        <!-- Game Area -->
        <div class="game-area" id="game-area">
            <div class="players-container">
                <div class="player active" id="player-0">
                    <div class="player-avatar" style="background-color: #e74c3c;">P1</div>
                    <div class="player-info">
                        <div class="player-name">Alex (You)</div>
                        <div>Cards: <span class="card-count">7</span></div>
                        <div class="player-cards">
                            <div class="card red" style="width: 25px; height: 35px;"></div>
                            <div class="card blue" style="width: 25px; height: 35px;"></div>
                            <div class="card green" style="width: 25px; height: 35px;"></div>
                        </div>
                    </div>
                </div>

                <div class="player" id="player-1">
                    <div class="player-avatar" style="background-color: #3498db;">P2</div>
                    <div class="player-info">
                        <div class="player-name">Sam</div>
                        <div>Cards: <span class="card-count">7</span></div>
                    </div>
                </div>

                <div class="player" id="player-2">
                    <div class="player-avatar" style="background-color: #2ecc71;">P3</div>
                    <div class="player-info">
                        <div class="player-name">Jordan</div>
                        <div>Cards: <span class="card-count">7</span></div>
                    </div>
                </div>

                <div class="player" id="player-3">
                    <div class="player-avatar" style="background-color: #f1c40f; color: #000;">P4</div>
                    <div class="player-info">
                        <div class="player-name">Taylor</div>
                        <div>Cards: <span class="card-count">7</span></div>
                    </div>
                </div>
            </div>

            <div class="game-board">
                <div class="deck-area">
                    <div class="deck"></div>
                    <div class="discard-pile card">
                        <div class="current-card red">7</div>
                    </div>
                </div>

                <div class="message-area" id="message">
                    Welcome to Uno Swap! It's your turn. Play a card that matches the color or number.
                </div>

                <div class="chat-area" id="chat-area">
                    <div class="chat-message npc">Alex: Let's play!</div>
                    <div class="chat-message npc">Sam: Good luck everyone!</div>
                </div>

                <div class="controls">
                    <button id="draw-btn">Draw Card</button>
                    <button id="uno-btn" disabled>UNO!</button>
                    <button id="pass-btn" disabled>Pass Turn</button>
                    <button id="new-game-btn">New Game</button>
                </div>

                <div class="hand" id="player-hand">
                    <!-- Cards will be generated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div class="game-over-screen" id="game-over-screen">
        <div class="game-over-content">
            <div class="game-over-title" id="game-over-title">Game Over!</div>
            <div id="winner-message"></div>
            <div id="player-identities"></div>
            <button id="play-again-btn">Play Again</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Game state
            const gameState = {
                players: [
                    { id: 0, name: 'Alex', cards: [], isActive: true, avatar: 'P1', color: '#e74c3c', gender: 'male', personality: 'strategist', originalName: 'Alex' },
                    { id: 1, name: 'Sam', cards: [], isActive: false, avatar: 'P2', color: '#3498db', gender: 'female', personality: 'trickster', originalName: 'Sam' },
                    { id: 2, name: 'Jordan', cards: [], isActive: false, avatar: 'P3', color: '#2ecc71', gender: 'male', personality: 'wildcard', originalName: 'Jordan' },
                    { id: 3, name: 'Taylor', cards: [], isActive: false, avatar: 'P4', color: '#f1c40f', gender: 'female', personality: 'collector', originalName: 'Taylor' }
                ],
                currentPlayer: 0,
                deck: [],
                discardPile: [],
                gameMessage: 'Welcome to Uno Body Swap! It\'s your turn. Play a card that matches the color or number.',
                playerSelected: 0,
                direction: 1, // 1 for clockwise, -1 for counterclockwise
                blockNextPlayer: false,
                drawAccumulator: 0,
                waitingForColor: false,
                swapCardUsed: false,
                hasDrawnCard: false,
                unoCalled: false
            };

            // Card types and counts - Standard Uno deck (108 cards) + Body Swap cards
            const cardTypes = [
                // Number cards (0-9) for each color
                ...['red', 'blue', 'green', 'yellow'].flatMap(color =>
                    [...Array(10).keys()].flatMap(value =>
                        Array(value === 0 ? 1 : 2).fill({ type: 'number', value: value.toString(), color })
                    )
                ),
                // Action cards for each color (2 of each)
                ...['red', 'blue', 'green', 'yellow'].flatMap(color =>
                    ['skip', 'reverse', 'draw2'].flatMap(type =>
                        Array(2).fill({ type, color })
                    )
                ),
                // Wild cards (4 of each)
                ...Array(4).fill({ type: 'wild', color: 'wild' }),
                ...Array(4).fill({ type: 'wild4', color: 'wild' }),
                // Body Swap cards (4 total)
                ...Array(4).fill({ type: 'bodyswap', color: 'wild' })
            ];

            // DOM elements
            const setupScreen = document.getElementById('setup-screen');
            const gameArea = document.getElementById('game-area');
            const messageArea = document.getElementById('message');
            const chatArea = document.getElementById('chat-area');
            const drawBtn = document.getElementById('draw-btn');
            const unoBtn = document.getElementById('uno-btn');
            const passBtn = document.getElementById('pass-btn');
            const newGameBtn = document.getElementById('new-game-btn');
            const playerHand = document.getElementById('player-hand');
            const deckArea = document.querySelector('.deck');
            const discardPile = document.querySelector('.discard-pile .current-card');
            const startGameBtn = document.getElementById('start-game-btn');
            const playerOptions = document.querySelectorAll('.player-option');
            const gameOverScreen = document.getElementById('game-over-screen');
            const winnerMessage = document.getElementById('winner-message');
            const playerIdentities = document.getElementById('player-identities');
            const playAgainBtn = document.getElementById('play-again-btn');

            // Initialize game
            function initGame() {
                setupPlayerSelection();
                setupEventListeners();
            }

            // Set up player selection
            function setupPlayerSelection() {
                playerOptions.forEach(option => {
                    option.addEventListener('click', function () {
                        playerOptions.forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        gameState.playerSelected = parseInt(this.getAttribute('data-player'));
                    });
                });

                // Select first player by default
                playerOptions[0].classList.add('selected');
            }

            // Start the game
            function startGame() {
                setupScreen.style.display = 'none';
                gameArea.style.display = 'flex';

                // Update player names to show which is human
                gameState.players.forEach((player, index) => {
                    if (index === gameState.playerSelected) {
                        player.name = player.originalName + ' (You)';
                    } else {
                        player.name = player.originalName;
                    }
                });

                initializeDeck();
                dealCards();
                startFirstTurn();
                updateGameDisplay();
            }

            // Initialize and shuffle the deck
            function initializeDeck() {
                gameState.deck = [...cardTypes];
                shuffleDeck();

                // Set first card (must be a number card)
                let firstCard;
                do {
                    firstCard = gameState.deck.pop();
                } while (firstCard.type !== 'number');

                gameState.discardPile = [firstCard];
            }

            // Shuffle the deck using Fisher-Yates algorithm
            function shuffleDeck() {
                for (let i = gameState.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
                }
            }

            // Deal 7 cards to each player
            function dealCards() {
                gameState.players.forEach(player => {
                    player.cards = [];
                    for (let i = 0; i < 7; i++) {
                        if (gameState.deck.length === 0) {
                            // Reshuffle discard pile if deck is empty (except top card)
                            const topCard = gameState.discardPile.pop();
                            gameState.deck = [...gameState.discardPile];
                            gameState.discardPile = [topCard];
                            shuffleDeck();
                        }
                        player.cards.push(gameState.deck.pop());
                    }
                });
            }

            // Start the first turn
            function startFirstTurn() {
                gameState.players[gameState.currentPlayer].isActive = true;
                gameState.gameMessage = `${gameState.players[gameState.currentPlayer].name}'s turn.`;

                // If it's the human player's turn, enable controls
                if (gameState.currentPlayer === gameState.playerSelected) {
                    enablePlayerControls();
                } else {
                    // AI turn after a delay
                    setTimeout(simulateAITurn, 1500);
                }
            }

            function updateGameDisplay() {
                // Update players
                gameState.players.forEach(player => {
                    const playerEl = document.getElementById(`player-${player.id}`);
                    const cardCountEl = playerEl.querySelector('.card-count');

                    playerEl.classList.toggle('active', player.isActive);
                    cardCountEl.textContent = player.cards.length;

                    // Update name to show if it's the human player
                    const nameEl = playerEl.querySelector('.player-name');
                    if (player.id === gameState.playerSelected) {
                        nameEl.textContent = player.name.replace(' (You)', '') + ' (You)';
                    } else {
                        nameEl.textContent = player.name.replace(' (You)', '');
                    }
                });

                // Update message
                messageArea.textContent = gameState.gameMessage;

                // Update current card with proper design
                const currentCard = gameState.discardPile[gameState.discardPile.length - 1];
                const displayValue = getCardDisplayValue(currentCard);
                discardPile.innerHTML = `
        <div class="card-corner top-left">${displayValue}</div>
        <div class="card-center">${displayValue}</div>
        <div class="card-corner bottom-right">${displayValue}</div>
    `;
                discardPile.className = 'current-card';
                discardPile.classList.add(currentCard.color);

                // Update deck count (visual only)
                deckArea.textContent = gameState.deck.length;

                // Update player hand if it's the human player's turn
                if (gameState.currentPlayer === gameState.playerSelected) {
                    updatePlayerHand();
                }
            }
            // Update the player's hand display
            function updatePlayerHand() {
                playerHand.innerHTML = '';
                const player = gameState.players[gameState.playerSelected];

                player.cards.forEach((card, index) => {
                    const cardEl = document.createElement('div');
                    cardEl.className = `card ${card.color}`;

                    // Create card content with corners
                    const displayValue = getCardDisplayValue(card);
                    cardEl.innerHTML = `
                        <div class="card-corner top-left">${displayValue}</div>
                        <div class="card-center">${displayValue}</div>
                        <div class="card-corner bottom-right">${displayValue}</div>
                    `;

                    cardEl.setAttribute('data-index', index);

                    // Add UNO call indicator if player has only one card
                    if (player.cards.length === 1) {
                        const unoCall = document.createElement('div');
                        unoCall.className = 'uno-call';
                        unoCall.textContent = 'UNO!';
                        unoCall.style.display = gameState.unoCalled ? 'block' : 'none';
                        cardEl.appendChild(unoCall);
                    }

                    playerHand.appendChild(cardEl);
                });
            }

            // Get display value for a card
            function getCardDisplayValue(card) {
                switch (card.type) {
                    case 'number': return card.value;
                    case 'skip': return 'Ã˜';
                    case 'reverse': return 'R';
                    case 'draw2': return '+2';
                    case 'wild': return 'W';
                    case 'wild4': return '+4';
                    case 'bodyswap': return 'SWAP';
                    default: return '?';
                }
            }

            // Set up event listeners
            function setupEventListeners() {
                // Start game button
                startGameBtn.addEventListener('click', startGame);

                // Draw card button
                drawBtn.addEventListener('click', function () {
                    if (gameState.currentPlayer === gameState.playerSelected && !gameState.waitingForColor) {
                        drawCard();
                    }
                });

                // Pass turn button
                passBtn.addEventListener('click', function () {
                    if (gameState.currentPlayer === gameState.playerSelected && !gameState.waitingForColor) {
                        passTurn();
                    }
                });

                // UNO button
                unoBtn.addEventListener('click', function () {
                    if (gameState.players[gameState.playerSelected].cards.length === 1) {
                        gameState.unoCalled = true;
                        addChatMessage(gameState.players[gameState.playerSelected].name, "UNO!");
                        unoBtn.disabled = true;
                        updatePlayerHand();
                    }
                });

                // New game button
                newGameBtn.addEventListener('click', function () {
                    resetGame();
                });

                // Play again button
                playAgainBtn.addEventListener('click', function () {
                    resetGame();
                });

                // Card click events
                playerHand.addEventListener('click', function (e) {
                    if (e.target.classList.contains('card') &&
                        gameState.currentPlayer === gameState.playerSelected &&
                        !gameState.waitingForColor) {

                        const cardIndex = parseInt(e.target.getAttribute('data-index'));
                        playCard(cardIndex);
                    }
                });

                // Deck click event
                deckArea.addEventListener('click', function () {
                    if (gameState.currentPlayer === gameState.playerSelected && !gameState.waitingForColor) {
                        drawCard();
                    }
                });
            }

            // Enable player controls
        function enablePlayerControls() {
    const player = gameState.players[gameState.playerSelected];
    
    // Always enable draw button (unless waiting for color selection)
    drawBtn.disabled = gameState.waitingForColor;
    
    // Check if player has any playable cards
    const hasPlayableCard = player.cards.some(card => canPlayCard(card));
    
    // Player can only pass if they've drawn a card and still can't play
    passBtn.disabled = !gameState.hasDrawnCard || hasPlayableCard || gameState.waitingForColor;
    
    // Update UNO button - only enable if player has exactly one card AND hasn't called UNO yet
    unoBtn.disabled = player.cards.length !== 1 || gameState.unoCalled || gameState.waitingForColor;
}
            // Disable player controls
            function disablePlayerControls() {
                drawBtn.disabled = true;
                passBtn.disabled = true;
                unoBtn.disabled = true;
            }
            function checkUnoViolation() {
                const player = gameState.players[gameState.currentPlayer];

                // If player has one card but didn't call UNO, they must draw penalty cards
                if (player.cards.length === 1 && !gameState.unoCalled) {
                    // Draw 2 penalty cards for forgetting UNO
                    for (let i = 0; i < 2; i++) {
                        if (gameState.deck.length === 0) {
                            // Reshuffle if needed
                            const topCard = gameState.discardPile.pop();
                            gameState.deck = [...gameState.discardPile];
                            gameState.discardPile = [topCard];
                            shuffleDeck();
                        }
                        player.cards.push(gameState.deck.pop());
                    }

                    addChatMessage("System", `${player.name} forgot to call UNO! Draw 2 penalty cards.`);
                    gameState.unoCalled = true; // Prevent multiple penalties

                    // If it's the human player, update their hand
                    if (gameState.currentPlayer === gameState.playerSelected) {
                        updatePlayerHand();
                    }

                    return true;
                }
                return false;
            }

            // Draw a card for the current player
            function drawCard() {
                const player = gameState.players[gameState.currentPlayer];

                if (gameState.deck.length === 0) {
                    // Reshuffle discard pile if deck is empty (except top card)
                    const topCard = gameState.discardPile.pop();
                    gameState.deck = [...gameState.discardPile];
                    gameState.discardPile = [topCard];
                    shuffleDeck();
                    addChatMessage("System", "The deck has been reshuffled!");
                }

                const drawnCard = gameState.deck.pop();
                player.cards.push(drawnCard);
                gameState.hasDrawnCard = true;

                addChatMessage(player.name, `drew a card`);

                // If it's the human player, update their hand
                if (gameState.currentPlayer === gameState.playerSelected) {
                    updatePlayerHand();

                    // Check if the drawn card can be played
                    if (canPlayCard(drawnCard)) {
                        gameState.gameMessage = "You drew a playable card! You can play it or pass.";
                        enablePlayerControls();
                    } else {
                        gameState.gameMessage = "You drew a card. It's not playable. Pass your turn.";
                        passBtn.disabled = false;
                    }
                } else {
                    // For AI, check if the drawn card can be played
                    if (canPlayCard(drawnCard)) {
                        // Find the index of the drawn card
                        const cardIndex = player.cards.length - 1;
                        setTimeout(() => playCard(cardIndex, true), 1500);
                        return;
                    } else {
                        setTimeout(nextTurn, 1500);
                    }
                }

                updateGameDisplay();
            }

            // Check if a card can be played
            function canPlayCard(card) {
                const currentCard = gameState.discardPile[gameState.discardPile.length - 1];

                // Wild cards (including swap) can always be played
                if (card.color === 'wild') return true;

                // Same color
                if (card.color === currentCard.color) return true;

                // Same value/type (for number and action cards)
                if (card.type === currentCard.type &&
                    (card.type === 'number' ? card.value === currentCard.value : true)) {
                    return true;
                }

                return false;
            }

            // Play a card
            function playCard(cardIndex, isAI = false) {
                const player = gameState.players[gameState.currentPlayer];
                const card = player.cards[cardIndex];

                // Check if card can be played
                if (!canPlayCard(card) && !isAI) {
                    gameState.gameMessage = "You can't play that card. It must match the color or number.";
                    updateGameDisplay();
                    return;
                }

                // Remove card from player's hand immediately
                player.cards.splice(cardIndex, 1);

                // Reset UNO call status for the next turn
                gameState.unoCalled = false;

                // Add card to discard pile
                gameState.discardPile.push(card);

                // If it's the human player, update their hand immediately
                if (gameState.currentPlayer === gameState.playerSelected) {
                    updatePlayerHand();
                }

                // Handle card effects
                handleCardEffect(card);

                // Add chat message
                addChatMessage(player.name, `played ${getCardDisplayValue(card)} ${card.color !== 'wild' ? card.color : ''}`);

                // Check for UNO violation BEFORE checking for win
                const unoViolation = checkUnoViolation();

                // If there was an UNO violation, we've already drawn penalty cards
                if (unoViolation && player.cards.length > 0) {
                    updateGameDisplay();
                    const delay = isAI ? Math.floor(Math.random() * 1500) + 1500 : 500;
                    setTimeout(nextTurn, delay);
                    return;
                }

                // Check for win
                if (player.cards.length === 0) {
                    endGame(player);
                    return;
                }

                // Check for UNO
                if (player.cards.length === 1 && !isAI && !unoViolation) {
                    gameState.gameMessage = "You have one card left! Press UNO!";
                    unoBtn.disabled = false;
                }

                updateGameDisplay();

                // For swap cards, the color selection will trigger the body swap
                // For other cards, proceed to next turn
                if (card.type === 'bodyswap' && !gameState.waitingForColor) {
                    triggerBodySwap();
                } else if (card.type !== 'bodyswap') {
                    const delay = isAI ? Math.floor(Math.random() * 1500) + 1500 : 500;
                    setTimeout(nextTurn, delay);
                }
                // If it's a swap card and we're waiting for color, the color selection will handle the swap
            }
            function addUnoChallenge(playerName, targetPlayerName) {
                addChatMessage(playerName, `calls UNO on ${targetPlayerName}!`);

                const targetPlayer = gameState.players.find(p => p.name === targetPlayerName);
                if (targetPlayer && targetPlayer.cards.length === 1 && !gameState.unoCalled) {
                    // Penalty for forgetting UNO
                    for (let i = 0; i < 2; i++) {
                        if (gameState.deck.length === 0) {
                            const topCard = gameState.discardPile.pop();
                            gameState.deck = [...gameState.discardPile];
                            gameState.discardPile = [topCard];
                            shuffleDeck();
                        }
                        targetPlayer.cards.push(gameState.deck.pop());
                    }
                    addChatMessage("System", `${targetPlayerName} forgot UNO! Draw 2 penalty cards.`);

                    // Update display if it's the human player
                    if (targetPlayer.id === gameState.playerSelected) {
                        updatePlayerHand();
                    }
                } else {
                    addChatMessage("System", `False UNO call! No penalty.`);
                }
            } function simulateAITurn() {
                const aiPlayer = gameState.players[gameState.currentPlayer];

                // First, check if any other player has one card but didn't call UNO
                const playersWithOneCard = gameState.players.filter(p =>
                    p.id !== gameState.currentPlayer &&
                    p.cards.length === 1 &&
                    !gameState.unoCalled
                );

                if (playersWithOneCard.length > 0 && Math.random() > 0.7) {
                    // AI challenges UNO
                    const targetPlayer = playersWithOneCard[Math.floor(Math.random() * playersWithOneCard.length)];
                    addUnoChallenge(aiPlayer.name, targetPlayer.name);
                }

                // Then proceed with normal turn
                // Find playable cards
                const playableCards = aiPlayer.cards.map((card, index) => ({ card, index }))
                    .filter(({ card }) => canPlayCard(card));

                if (playableCards.length > 0) {
                    // AI plays a card
                    const actionCards = playableCards.filter(({ card }) => card.type !== 'number');
                    const cardToPlay = actionCards.length > 0 ?
                        actionCards[Math.floor(Math.random() * actionCards.length)] :
                        playableCards[Math.floor(Math.random() * playableCards.length)];

                    playCard(cardToPlay.index, true);
                } else {
                    // AI draws a card
                    drawCard();
                }
            }
            // Handle card effects
            function handleCardEffect(card) {
                const currentCard = gameState.discardPile[gameState.discardPile.length - 1];

                switch (card.type) {
                    case 'skip':
                        gameState.blockNextPlayer = true;
                        break;
                    case 'reverse':
                        gameState.direction *= -1;
                        if (gameState.players.length === 2) {
                            gameState.blockNextPlayer = true;
                        }
                        break;
                    case 'draw2':
                        gameState.drawAccumulator += 2;
                        gameState.blockNextPlayer = true;
                        break;
                    case 'wild4':
                        gameState.drawAccumulator += 4;
                        gameState.blockNextPlayer = true;
                        gameState.waitingForColor = true;

                        // Set a default color immediately to prevent issues
                        currentCard.color = 'red'; // Default color

                        if (gameState.currentPlayer === gameState.playerSelected) {
                            // Human player needs to choose a color
                            gameState.gameMessage = "Choose a color for the wild +4 card";
                            showColorSelection(true);
                        } else {
                            // AI chooses a color randomly
                            setTimeout(() => {
                                const colors = ['red', 'blue', 'green', 'yellow'];
                                const chosenColor = colors[Math.floor(Math.random() * colors.length)];
                                currentCard.color = chosenColor;
                                gameState.waitingForColor = false;
                                addChatMessage(gameState.players[gameState.currentPlayer].name, `chose ${chosenColor}`);
                                updateGameDisplay(); // Update display with new color
                            }, 1500);
                        }
                        break;
                    case 'wild':
                        gameState.waitingForColor = true;

                        // Set a default color immediately to prevent issues
                        currentCard.color = 'red'; // Default color

                        if (gameState.currentPlayer === gameState.playerSelected) {
                            // Human player needs to choose a color
                            gameState.gameMessage = "Choose a color for the wild card";
                            showColorSelection(false);
                        } else {
                            // AI chooses a color randomly
                            setTimeout(() => {
                                const colors = ['red', 'blue', 'green', 'yellow'];
                                const chosenColor = colors[Math.floor(Math.random() * colors.length)];
                                currentCard.color = chosenColor;
                                gameState.waitingForColor = false;
                                addChatMessage(gameState.players[gameState.currentPlayer].name, `chose ${chosenColor}`);
                                updateGameDisplay(); // Update display with new color
                            }, 1500);
                        }
                        break;
                    // In handleCardEffect function, update the bodyswap case:
                    case 'bodyswap':
                        // Body swap cards also need a color for the next player
                        gameState.waitingForColor = true;

                        // Set a default color immediately to prevent issues
                        currentCard.color = 'red'; // Default color

                        if (gameState.currentPlayer === gameState.playerSelected) {
                            // Human player needs to choose a color
                            gameState.gameMessage = "Choose a color for the swap card";
                            showColorSelection(false, true); // isSwap = true
                        } else {
                            // AI chooses a color randomly
                            setTimeout(() => {
                                const colors = ['red', 'blue', 'green', 'yellow'];
                                const chosenColor = colors[Math.floor(Math.random() * colors.length)];
                                currentCard.color = chosenColor;
                                gameState.waitingForColor = false;
                                addChatMessage(gameState.players[gameState.currentPlayer].name, `chose ${chosenColor}`);
                                updateGameDisplay();

                                // Trigger body swap after color selection
                                triggerBodySwap();
                            }, 1500);
                        }
                        break;
                }
            }

            // Show color selection for wild cards
      function showColorSelection(isWild4 = false, isSwap = false) {
    const colorOptions = ['red', 'blue', 'green', 'yellow'];
    const colorSelection = document.createElement('div');
    colorSelection.className = 'color-selection';
    
    let displaySymbol = 'W';
    if (isWild4) displaySymbol = '+4';
    if (isSwap) displaySymbol = 'SWAP';
    
    colorSelection.innerHTML = `
        ${colorOptions.map(color => 
            `<div class="color-option ${color}" data-color="${color}">${displaySymbol}</div>`
        ).join('')}
    `;
    
    messageArea.appendChild(colorSelection);
    
    // Add event listeners to color options
    colorSelection.querySelectorAll('.color-option').forEach(option => {
        option.addEventListener('click', function() {
            const chosenColor = this.getAttribute('data-color');
            gameState.discardPile[gameState.discardPile.length - 1].color = chosenColor;
            gameState.waitingForColor = false;
            messageArea.removeChild(colorSelection);
            addChatMessage(gameState.players[gameState.currentPlayer].name, `chose ${chosenColor}`);
            
            // Update display immediately with the new color
            updateGameDisplay();
            
            if (isSwap) {
                // For swap cards, trigger the body swap after color selection
                setTimeout(() => {
                    triggerBodySwap();
                }, 500);
            } else {
                // For regular wild cards, continue to next turn
                nextTurn();
            }
        });
    });
}
            // Pass turn
            function passTurn() {
                addChatMessage(gameState.players[gameState.currentPlayer].name, "passed their turn");
                nextTurn();
            }

            // Move to next player's turn
        function nextTurn() {
    // Reset hasDrawnCard for next player
    gameState.hasDrawnCard = false;
    
    // Reset UNO called status for new turn
    gameState.unoCalled = false;
    
    // Handle draw accumulator
    if (gameState.drawAccumulator > 0 && !gameState.blockNextPlayer) {
        const nextPlayerIndex = getNextPlayerIndex();
        const nextPlayer = gameState.players[nextPlayerIndex];
        
        // Check if next player has a draw2 card to counter
        const hasDraw2 = nextPlayer.cards.some(card => card.type === 'draw2');
        const hasWild4 = nextPlayer.cards.some(card => card.type === 'wild4');
        
        if ((gameState.drawAccumulator === 2 && hasDraw2) || (gameState.drawAccumulator >= 2 && hasWild4)) {
            // Player can counter the draw
            gameState.currentPlayer = nextPlayerIndex;
            gameState.players[gameState.currentPlayer].isActive = true;
            gameState.gameMessage = `${nextPlayer.name} can counter the draw!`;
            updateGameDisplay();
            
            if (gameState.currentPlayer === gameState.playerSelected) {
                enablePlayerControls();
            } else {
                // AI will counter if possible
                setTimeout(() => {
                    const counterCardIndex = nextPlayer.cards.findIndex(card => 
                        (gameState.drawAccumulator === 2 && card.type === 'draw2') || 
                        (gameState.drawAccumulator >= 2 && card.type === 'wild4'));
                    
                    if (counterCardIndex !== -1) {
                        playCard(counterCardIndex, true);
                        gameState.drawAccumulator += (nextPlayer.cards[counterCardIndex].type === 'draw2' ? 2 : 4);
                    } else {
                        // Draw the cards
                        for (let i = 0; i < gameState.drawAccumulator; i++) {
                            if (gameState.deck.length === 0) {
                                const topCard = gameState.discardPile.pop();
                                gameState.deck = [...gameState.discardPile];
                                gameState.discardPile = [topCard];
                                shuffleDeck();
                            }
                            nextPlayer.cards.push(gameState.deck.pop());
                        }
                        
                        addChatMessage(nextPlayer.name, `drew ${gameState.drawAccumulator} cards!`);
                        gameState.drawAccumulator = 0;
                        completeTurnChange();
                    }
                }, 1500);
            }
            return;
        } else {
            // Draw cards for the next player
            for (let i = 0; i < gameState.drawAccumulator; i++) {
                if (gameState.deck.length === 0) {
                    const topCard = gameState.discardPile.pop();
                    gameState.deck = [...gameState.discardPile];
                    gameState.discardPile = [topCard];
                    shuffleDeck();
                }
                nextPlayer.cards.push(gameState.deck.pop());
            }
            
            addChatMessage(nextPlayer.name, `drew ${gameState.drawAccumulator} cards!`);
            gameState.drawAccumulator = 0;
            
            // Skip the next player's turn
            gameState.currentPlayer = getNextPlayerIndex();
        }
    }
    
    completeTurnChange();
}

            // Complete the turn change
            function completeTurnChange() {
                // Handle block
                if (gameState.blockNextPlayer) {
                    gameState.blockNextPlayer = false;
                    gameState.currentPlayer = getNextPlayerIndex();
                }

                // Deactivate current player
                gameState.players[gameState.currentPlayer].isActive = false;

                // Move to next player
                gameState.currentPlayer = getNextPlayerIndex();

                // Activate next player
                gameState.players[gameState.currentPlayer].isActive = true;

                // Update game message
                gameState.gameMessage = `${gameState.players[gameState.currentPlayer].name}'s turn.`;

                // If it's the human player's turn, enable controls
                if (gameState.currentPlayer === gameState.playerSelected) {
                    enablePlayerControls();
                } else {
                    // AI turn after a delay
                    disablePlayerControls();
                    setTimeout(simulateAITurn, 1500);
                }

                updateGameDisplay();
            }

            // Get the next player index based on direction
            function getNextPlayerIndex() {
                let nextPlayer = gameState.currentPlayer + gameState.direction;
                if (nextPlayer < 0) nextPlayer = gameState.players.length - 1;
                if (nextPlayer >= gameState.players.length) nextPlayer = 0;
                return nextPlayer;
            }

            // Simulate AI player's turn
            function simulateAITurn() {
                const aiPlayer = gameState.players[gameState.currentPlayer];

                // Find playable cards
                const playableCards = aiPlayer.cards.map((card, index) => ({ card, index }))
                    .filter(({ card }) => canPlayCard(card));

                if (playableCards.length > 0) {
                    // AI plays a card (prefer action cards)
                    const actionCards = playableCards.filter(({ card }) =>
                        card.type !== 'number');

                    const cardToPlay = actionCards.length > 0 ?
                        actionCards[Math.floor(Math.random() * actionCards.length)] :
                        playableCards[Math.floor(Math.random() * playableCards.length)];

                    playCard(cardToPlay.index, true);
                } else {
                    // AI draws a card
                    drawCard();
                }
            }

            // Trigger body swap animation and effect
            function triggerBodySwap() {
                // If we're still waiting for color selection, don't proceed with swap yet
                if (gameState.waitingForColor) {
                    return;
                }

                // Determine which players to swap (not the current player)
                const availablePlayers = gameState.players
                    .map((player, index) => ({ player, index }))
                    .filter(({ index }) => index !== gameState.currentPlayer);

                const swapWith = availablePlayers[Math.floor(Math.random() * availablePlayers.length)];
                const currentPlayerIndex = gameState.currentPlayer;
                const swapWithIndex = swapWith.index;

                // Check if target has a body swap card to counter
                const targetPlayer = gameState.players[swapWithIndex];
                const hasSwapCard = targetPlayer.cards.some(card => card.type === 'bodyswap');

                if (hasSwapCard && Math.random() > 0.5) {
                    // Target counters the swap
                    addChatMessage(targetPlayer.name, "Countered the body swap!");

                    // Find another player to swap with
                    const otherPlayers = availablePlayers.filter(({ index }) => index !== swapWithIndex);
                    if (otherPlayers.length > 0) {
                        const newSwapWith = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
                        performBodySwap(currentPlayerIndex, newSwapWith.index);
                    } else {
                        // No other players to swap with, swap fails
                        addChatMessage("System", "Body swap failed!");
                        nextTurn();
                    }
                } else {
                    // Perform the swap
                    performBodySwap(currentPlayerIndex, swapWithIndex);
                }
            }

            // Perform the actual body swap
            function performBodySwap(player1Index, player2Index) {
                // Create body swap animation
                const swapAnimation = document.createElement('div');
                swapAnimation.className = 'body-swap-animation';
                swapAnimation.innerHTML = `
        <div class="swap-content">
            <div class="swap-title">BODY SWAP!</div>
            <div class="swap-players">
                <div class="swap-player">
                    <div class="swap-avatar" style="background-color: ${gameState.players[player1Index].color}">${gameState.players[player1Index].avatar}</div>
                    <div>${gameState.players[player1Index].name}</div>
                </div>
                <div style="font-size: 2rem;">â‡„</div>
                <div class="swap-player">
                    <div class="swap-avatar" style="background-color: ${gameState.players[player2Index].color}">${gameState.players[player2Index].avatar}</div>
                    <div>${gameState.players[player2Index].name}</div>
                </div>
            </div>
            <p>${gameState.players[player1Index].name} and ${gameState.players[player2Index].name} have swapped bodies!</p>
            <button id="continue-btn">Continue Game</button>
        </div>
    `;

                document.body.appendChild(swapAnimation);

                // Add body swap reactions
                addBodySwapReactions(gameState.players[player1Index], gameState.players[player2Index]);

                // Continue button
                document.getElementById('continue-btn').addEventListener('click', function () {
                    // Swap player identities (names, avatars, colors) but KEEP their original cards
                    const tempName = gameState.players[player1Index].name;
                    const tempAvatar = gameState.players[player1Index].avatar;
                    const tempColor = gameState.players[player1Index].color;
                    const tempGender = gameState.players[player1Index].gender;
                    const tempPersonality = gameState.players[player1Index].personality;
                    const tempOriginalName = gameState.players[player1Index].originalName;

                    gameState.players[player1Index].name = gameState.players[player2Index].name;
                    gameState.players[player1Index].avatar = gameState.players[player2Index].avatar;
                    gameState.players[player1Index].color = gameState.players[player2Index].color;
                    gameState.players[player1Index].gender = gameState.players[player2Index].gender;
                    gameState.players[player1Index].personality = gameState.players[player2Index].personality;
                    gameState.players[player1Index].originalName = gameState.players[player2Index].originalName;

                    gameState.players[player2Index].name = tempName;
                    gameState.players[player2Index].avatar = tempAvatar;
                    gameState.players[player2Index].color = tempColor;
                    gameState.players[player2Index].gender = tempGender;
                    gameState.players[player2Index].personality = tempPersonality;
                    gameState.players[player2Index].originalName = tempOriginalName;

                    // Update IDs to maintain consistency
                    gameState.players[player1Index].id = player1Index;
                    gameState.players[player2Index].id = player2Index;

                    // If human player was involved in swap, update the playerSelected index
                    if (gameState.playerSelected === player1Index) {
                        gameState.playerSelected = player2Index;
                    } else if (gameState.playerSelected === player2Index) {
                        gameState.playerSelected = player1Index;
                    }

                    // Remove animation
                    document.body.removeChild(swapAnimation);

                    // IMPORTANT: Continue with next turn after swap
                    // Reset the waiting state and move to next player
                    gameState.waitingForColor = false;

                    // Update the display
                    updateGameDisplay();

                    // Continue with next turn after a short delay
                    setTimeout(() => {
                        nextTurn();
                    }, 1000);
                });
            }

            // Add body swap reactions to chat
            function addBodySwapReactions(player1, player2) {
                const reactions = [
                    "Whoa! What just happened?",
                    "I feel... different.",
                    "Is this what it's like to be in your body?",
                    "My chest feels so heavy!",
                    "Wait, where did my... never mind.",
                    "I'm suddenly very aware of my... everything.",
                    "This is so weird!",
                    "I don't know how you walk around like this!",
                    "Something feels... missing.",
                    "I have a sudden craving for your favorite food."
                ];

                const genderReactions = {
                    'male': [
                        "Whoa, this voice is so deep!",
                        "I keep trying to adjust my... never mind.",
                        "Why is everything so... hairy?"
                    ],
                    'female': [
                        "Wow, my center of gravity is completely different!",
                        "How do you walk in this body?",
                        "My chest feels so heavy!"
                    ]
                };

                // Add reactions for both players
                setTimeout(() => {
                    addChatMessage(player1.name, reactions[Math.floor(Math.random() * reactions.length)]);

                    if (genderReactions[player2.gender]) {
                        addChatMessage(player1.name, genderReactions[player2.gender][Math.floor(Math.random() * genderReactions[player2.gender].length)]);
                    }
                }, 500);

                setTimeout(() => {
                    addChatMessage(player2.name, reactions[Math.floor(Math.random() * reactions.length)]);

                    if (genderReactions[player1.gender]) {
                        addChatMessage(player2.name, genderReactions[player1.gender][Math.floor(Math.random() * genderReactions[player1.gender].length)]);
                    }
                }, 1500);
            }

            // End the game
            function endGame(winner) {
                gameState.gameMessage = `${winner.name} wins the game!`;
                addChatMessage("System", `${winner.name} wins the game!`);
                disablePlayerControls();
                updateGameDisplay();

                // Show game over screen after a delay
                setTimeout(() => {
                    showGameOverScreen(winner);
                }, 2000);
            }

            // Show game over screen with player identities
            function showGameOverScreen(winner) {
                gameOverScreen.style.display = 'flex';
                document.getElementById('game-over-title').textContent = `${winner.name} Wins!`;
                winnerMessage.textContent = `${winner.name} has won the game of Uno Body Swap!`;

                // Show player identities
                playerIdentities.innerHTML = '<h3>Final Player Identities:</h3>';
                gameState.players.forEach(player => {
                    const identityEl = document.createElement('div');
                    identityEl.className = 'player-identity';
                    identityEl.innerHTML = `
                        <div class="player-identity-avatar" style="background-color: ${player.color}">${player.avatar}</div>
                        <div>
                            <div><strong>${player.name}</strong></div>
                            <div>Originally: ${player.originalName}</div>
                            <div>Cards: ${player.cards.length}</div>
                        </div>
                    `;
                    playerIdentities.appendChild(identityEl);
                });
            }

            // Add a message to the chat
            function addChatMessage(sender, message) {
                const messageEl = document.createElement('div');
                messageEl.className = `chat-message ${sender === gameState.players[gameState.playerSelected].name ? 'player' : 'npc'}`;
                messageEl.innerHTML = `<strong>${sender}:</strong> ${message}`;
                chatArea.appendChild(messageEl);
                chatArea.scrollTop = chatArea.scrollHeight;
            }

            // Reset the game
            function resetGame() {
                gameArea.style.display = 'none';
                setupScreen.style.display = 'block';
                gameOverScreen.style.display = 'none';

                // Reset game state
                gameState.players.forEach((player, index) => {
                    player.cards = [];
                    player.isActive = index === 0;
                    player.name = player.originalName;
                    player.avatar = `P${index + 1}`;
                    player.color = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f'][index];
                });

                gameState.currentPlayer = 0;
                gameState.deck = [];
                gameState.discardPile = [];
                gameState.gameMessage = 'Welcome to Uno Body Swap! It\'s your turn. Play a card that matches the color or number.';
                gameState.direction = 1;
                gameState.blockNextPlayer = false;
                gameState.drawAccumulator = 0;
                gameState.waitingForColor = false;
                gameState.playerSelected = 0;
                gameState.swapCardUsed = false;
                gameState.hasDrawnCard = false;
                gameState.unoCalled = false;
                gameState.unoCalled = false;

                // Clear chat
                chatArea.innerHTML = '<div class="chat-message npc">Alex: Let\'s play!</div><div class="chat-message npc">Sam: Good luck everyone!</div>';

                // Clear hand
                playerHand.innerHTML = '';
            }

            // Initialize the game
            initGame();
        });
        getCardDisplayValue

    </script>
</body>

</html>
