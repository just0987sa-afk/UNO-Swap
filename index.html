<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO - Professional Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: #1a5e34;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)),
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%231a5e34"/><path d="M0 0L100 100M100 0L0 100" stroke="%23147d3c" stroke-width="1"/></svg>');
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            border: 2px solid #ffde59;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            color: #ffde59;
            text-shadow: 3px 3px 0 #000;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #fff;
        }

        /* Setup Screen */
        .setup-screen {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 20px;
            text-align: center;
            border: 2px solid #ffde59;
        }

        .player-setup {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }

        .player-option {
            background: #2d7d46;
            border-radius: 10px;
            padding: 15px;
            width: 200px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .player-option:hover {
            background: #3d9d56;
            transform: translateY(-5px);
        }

        .player-option.selected {
            background: #ffde59;
            border: 2px solid #000;
            color: #000;
        }

        .option-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: bold;
            border: 3px solid #000;
            background: #fff;
            color: #000;
        }

        .option-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .option-gender {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        /* Game Area */
        .game-area {
            display: none;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }

        .players-container {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .player {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            position: relative;
        }

        .player.active {
            background: rgba(255, 222, 89, 0.2);
            transform: scale(1.03);
            border: 2px solid #ffde59;
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 3px solid #fff;
            background: #2d7d46;
            color: #fff;
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .player-cards {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .card-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.9rem;
        }

        .game-board {
            flex: 2;
            min-width: 500px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid #ffde59;
        }

        .deck-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin: 20px 0;
            width: 100%;
        }

        .deck,
        .discard-pile {
            width: 120px;
            height: 170px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition: transform 0.2s;
            border: 2px solid #000;
            position: relative;
            overflow: hidden;
        }

        .deck {
            background: #2d7d46;
            color: #fff;
            font-weight: bold;
            background-image:
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.2) 0%, transparent 20%),
                radial-gradient(circle at 70% 70%, rgba(255, 255, 255, 0.1) 0%, transparent 20%);
        }

        .deck::before {
            content: "UNO";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .discard-pile {
            background: #fff;
            color: #000;
            font-weight: bold;
            position: relative;
        }

        .discard-pile .current-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .discard-pile .current-card::before {
            content: "";
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .discard-pile .card-corner {
            position: absolute;
            font-size: 1rem;
            font-weight: bold;
            z-index: 1;
        }

        .discard-pile .card-corner.top-left {
            top: 5px;
            left: 8px;
        }

        .discard-pile .card-corner.bottom-right {
            bottom: 5px;
            right: 8px;
            transform: rotate(180deg);
        }

        .discard-pile .card-center {
            font-size: 2.5rem;
            font-weight: bold;
            z-index: 1;
        }

        .deck:hover {
            transform: scale(1.05);
        }

        .current-card {
            font-size: 2.5rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            background: #ffde59;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 2px solid #000;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: #ffed9e;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.5;
            color: #ccc;
        }

        .hand {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            min-height: 180px;
        }

        .card {
            width: 90px;
            height: 130px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            border: 3px solid #fff;
            overflow: hidden;
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.3),
                inset 0 0 20px rgba(255, 255, 255, 0.1);
        }

        /* Color-specific borders */
        .card.red {
            background: #e74c3c;
            color: white;
            border-color: #ffffff;
        }

        .card.blue {
            background: #3498db;
            color: white;
            border-color: #ffffff;
        }

        .card.green {
            background: #2ecc71;
            color: white;
            border-color: #ffffff;
        }

        .card.yellow {
            background: #f1c40f;
            color: #000;
            border-color: #ffffff;
        }

        .card.wild {
            background: linear-gradient(45deg, #000, #333);
            color: white;
            border-color: #fff;
        }

        /* Enhanced card ellipse */
        .card::before {
            content: "";
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        /* Improved card corners */
        .card-corner {
            position: absolute;
            font-size: 1.1rem;
            font-weight: bold;
            z-index: 1;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 2px 4px;
        }

        .card-corner.top-left {
            top: 8px;
            left: 8px;
        }

        .card-corner.bottom-right {
            bottom: 8px;
            right: 8px;
            transform: rotate(180deg);
        }

        /* Improved card center */
        .card-center {
            font-size: 2.8rem;
            font-weight: bold;
            z-index: 1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* Special styling for action cards */
        .card .card-center {
            font-size: 2.5rem;
        }

        .card.wild .card-center {
            font-size: 2rem;
        }

        .card[class*="bodyswap"] .card-center {
            font-size: 1.6rem;
        }

        /* Enhanced discard pile card */
        .discard-pile .current-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            border: 3px solid #fff;
            border-radius: 8px;
        }

        .discard-pile .current-card::before {
            content: "";
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .message-area {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            min-height: 80px;
            width: 100%;
            text-align: center;
            font-size: 1.1rem;
            border: 1px solid #ffde59;
        }

        .chat-area {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ffde59;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        .chat-message.player {
            background: rgba(255, 222, 89, 0.3);
            text-align: right;
        }

        .chat-message.npc {
            background: rgba(52, 152, 219, 0.3);
        }

        .body-swap-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            animation: fadeIn 0.5s;
        }

        .mini-card.card-back {
            background: linear-gradient(135deg, #2d7d46, #1a5e34);
            color: white;
            border: 1px solid #fff;
        }

        .mini-card.card-back::before {
            content: "";
            position: absolute;
            width: 12px;
            height: 12px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .swap-content {
            background: #1a5e34;
            color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            animation: pulse 1s infinite;
            border: 3px solid #ffde59;
            box-shadow: 0 0 30px rgba(255, 222, 89, 0.5);
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 222, 89, 0.5);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 0 40px rgba(255, 222, 89, 0.7);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 222, 89, 0.5);
            }
        }

        .swap-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #ffde59;
            text-shadow: 2px 2px 0 #000;
        }

        .swap-players {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
        }

        .swap-player {
            text-align: center;
        }

        .swap-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            margin: 0 auto 10px;
            border: 4px solid #ffde59;
            background: #2d7d46;
            color: #fff;
        }

        .card.wild .card-center {
            font-size: 1.8rem;
        }

        .color-option.wild {
            background: #000;
            color: white;
        }

        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-over-content {
            background: #1a5e34;
            color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 600px;
            border: 3px solid #ffde59;
            box-shadow: 0 0 30px rgba(255, 222, 89, 0.5);
        }

        .game-over-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #ffde59;
            text-shadow: 2px 2px 0 #000;
        }

        .player-identity {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            align-items: center;
        }

        .player-identity-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 2px solid #fff;
        }

        .identity-info {
            flex: 1;
        }

        .original-identity {
            font-size: 0.9rem;
            opacity: 0.8;
            font-style: italic;
        }

        .uno-call {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #ffde59;
            color: #000;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            border: 2px solid #000;
            z-index: 10;
            display: none;
        }

        .red {
            background: #e74c3c;
            color: white;
        }

        .blue {
            background: #3498db;
            color: white;
        }

        .green {
            background: #2ecc71;
            color: white;
        }

        .yellow {
            background: #f1c40f;
            color: #000;
        }

        .color-selection {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
            width: 100%;
        }

        .color-option {
            width: 80px;
            height: 120px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid #fff;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .color-option.red {
            background: #e74c3c;
            color: white;
        }

        .color-option.blue {
            background: #3498db;
            color: white;
        }

        .color-option.green {
            background: #2ecc71;
            color: white;
        }

        .color-option.yellow {
            background: #f1c40f;
            color: #000;
        }

        .color-option::before {
            content: "";
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .color-option:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            border-color: #ffde59;
        }

        .color-option .card-corner {
            position: absolute;
            font-size: 0.9rem;
            font-weight: bold;
            z-index: 1;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 2px 4px;
        }

        .color-option .card-corner.top-left {
            top: 6px;
            left: 6px;
        }

        .color-option .card-corner.bottom-right {
            bottom: 6px;
            right: 6px;
            transform: rotate(180deg);
        }

        .color-option .card-center {
            font-size: 1.8rem;
            font-weight: bold;
            z-index: 1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .uno-indicator {
            background: #ffde59;
            color: #000;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
            display: none;
        }

        .message-area {
            min-height: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.05);
            z-index: 10;
        }

        .player.active {
            box-shadow: 0 0 15px rgba(255, 222, 89, 0.5);
        }

        .message-area {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            min-height: 150px;
            width: 100%;
            text-align: center;
            font-size: 1.1rem;
            border: 1px solid #ffde59;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .notification-area {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 300px;
        }

        .notification {
            background: rgba(0, 0, 0, 0.9);
            color: #ffde59;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #ffde59;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            animation: slideInRight 0.3s ease;
            font-weight: bold;
        }

        .notification.warning {
            border-left-color: #e74c3c;
            color: #e74c3c;
        }

        .notification.success {
            border-left-color: #2ecc71;
            color: #2ecc71;
        }

        .notification.info {
            border-left-color: #3498db;
            color: #3498db;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .settings-panel {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            width: 100%;
            border: 1px solid #ffde59;
            display: none;
        }

        .settings-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #ffde59;
            text-align: center;
        }

        .settings-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }

        .setting-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stats-panel {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            width: 100%;
            border: 1px solid #ffde59;
            display: none;
        }

        .stats-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #ffde59;
            text-align: center;
        }

        .stats-content {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            min-width: 120px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffde59;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .card-back {
            background: linear-gradient(135deg, #2d7d46, #1a5e34);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
        }

        .card-back::before {
            content: "UNO";
            position: absolute;
        }

        .rules-panel {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            width: 100%;
            border: 1px solid #ffde59;
            display: none;
        }

        .rules-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #ffde59;
            text-align: center;
        }

        .rules-content {
            text-align: left;
            line-height: 1.6;
        }

        .rules-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .rules-content li {
            margin-bottom: 8px;
        }

        .player-card-preview {
            display: flex;
            gap: 3px;
            margin-top: 5px;
            flex-wrap: wrap;
            max-width: 100%;
        }

        .mini-card {
            width: 20px;
            height: 28px;
            border-radius: 3px;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: relative;
            overflow: hidden;
            border: 1px solid #fff;
        }

        .mini-card::before {
            content: "";
            position: absolute;
            width: 12px;
            height: 12px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .mini-card .card-center {
            font-size: 0.7rem;
            z-index: 1;
        }

        .swap-message {
            font-size: 1.2rem;
            margin-top: 15px;
            font-style: italic;
            color: #ffde59;
            min-height: 40px;
        }

        .uno-call-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .uno-call-btn {
            background: #ff3860;
            color: white;
            border: 2px solid #fff;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .uno-call-btn:hover {
            background: #ff2b56;
            transform: scale(1.05);
        }

        .uno-call-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .uno-status {
            font-size: 1rem;
            padding: 5px 10px;
            border-radius: 10px;
            background: rgba(255, 222, 89, 0.2);
        }

        .counter-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .counter-btn {
            background: #9b59b6;
            color: white;
            border: 2px solid #fff;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .counter-btn:hover {
            background: #8e44ad;
            transform: scale(1.05);
        }

        .counter-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .pink-fog {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 182, 193, 0.7) 0%, rgba(255, 105, 180, 0.5) 50%, transparent 70%);
            animation: fogPulse 2s infinite;
            z-index: 1;
        }

        .blue-fog {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(173, 216, 230, 0.7) 0%, rgba(135, 206, 250, 0.5) 50%, transparent 70%);
            animation: fogPulse 2s infinite;
            z-index: 1;
        }

        .grey-fog {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(192, 192, 192, 0.7) 0%, rgba(169, 169, 169, 0.5) 50%, transparent 70%);
            animation: fogPulse 2s infinite;
            z-index: 1;
        }

        @keyframes fogPulse {
            0% {
                opacity: 0.3;
                transform: scale(1);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }

            100% {
                opacity: 0.3;
                transform: scale(1);
            }
        }

        .swap-animation-container {
            position: relative;
            width: 100%;
            height: 200px;
            margin: 20px 0;
        }

        .swap-animation {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .swap-arrow {
            font-size: 3rem;
            margin: 0 20px;
            animation: arrowPulse 1s infinite;
        }

        @keyframes arrowPulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        .uno-challenge-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .uno-challenge-btn {
            background: #e74c3c;
            color: white;
            border: 2px solid #fff;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .uno-challenge-btn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        .uno-challenge-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        /* Enhanced body swap animation */
        .swap-avatar-animated {
            animation: swapAvatar 2s ease-in-out;
            position: relative;
            z-index: 10;
        }

        @keyframes swapAvatar {
            0% {
                transform: translateX(0) scale(1);
            }

            25% {
                transform: translateX(50px) scale(1.1);
            }

            50% {
                transform: translateX(0) scale(1.2);
                filter: brightness(1.5);
            }

            75% {
                transform: translateX(-50px) scale(1.1);
            }

            100% {
                transform: translateX(0) scale(1);
            }
        }

        .energy-beam {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 222, 89, 0.8) 0%, transparent 70%);
            animation: energyPulse 1.5s ease-in-out;
            z-index: 5;
        }

        @keyframes energyPulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }

            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        .swap-flash {
            position: absolute;
            width: 100%;
            height: 100%;
            background: white;
            animation: flash 0.3s ease-in-out;
            z-index: 15;
        }

        @keyframes flash {
            0% {
                opacity: 0;
            }

            50% {
                opacity: 0.8;
            }

            100% {
                opacity: 0;
            }
        }
/* NEW: Chat Interface Styles - PC (Left Position) */
.npc-chat-interface {
    position: fixed;
    top: 50%;
    left: 20%;
    transform: translate(-50%, -50%);
    width: 400px;
    background: rgba(0, 0, 0, 0.95);
    border: 3px solid #ffde59;
    border-radius: 15px;
    z-index: 1000;
    display: none;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
    /* Make it movable/draggable */
    cursor: move;
    user-select: none;
}

.chat-header {
    background: #ffde59;
    color: #000;
    padding: 15px;
    border-radius: 12px 12px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: move;
}

.chat-title {
    font-size: 1.3rem;
    font-weight: bold;
}

.close-chat {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #000;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background-color 0.3s ease;
}

.close-chat:hover {
    background: rgba(0, 0, 0, 0.1);
}

.chat-messages {
    height: 300px;
    overflow-y: auto;
    padding: 15px;
    background: rgba(255, 255, 255, 0.1);
}

.chat-input-area {
    padding: 15px;
    border-top: 2px solid #ffde59;
}

.chat-input {
    width: 100%;
    padding: 10px;
    border: 2px solid #ffde59;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.9);
    color: #000;
    margin-bottom: 10px;
}

.chat-send-btn {
    width: 100%;
    padding: 10px;
    background: #ffde59;
    color: #000;
    border: none;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
}

.npc-chat-btn {
    background: #9b59b6;
    color: white;
    border: 2px solid #fff;
}

.npc-chat-btn:hover {
    background: #8e44ad;
}

/* Mobile Optimizations - Center and Make Movable */
@media (max-width: 768px) {
    .npc-chat-interface {
        /* Center on mobile */
        left: 50% !important;
        transform: translate(-50%, -50%) !important;
        width: 90%;
        max-width: 350px;
        max-height: 70vh;
        /* Make it movable on mobile */
        touch-action: none;
    }

    .chat-header {
        padding: 12px 15px;
        min-height: 50px;
        touch-action: none;
    }

    .chat-title {
        font-size: 1.1rem;
    }

    .close-chat {
        font-size: 1.3rem;
        width: 35px;
        height: 35px;
        min-width: 35px;
        min-height: 35px;
    }

    .chat-messages {
        height: 200px;
        max-height: 50vh;
        padding: 12px;
        font-size: 0.9rem;
    }

    .chat-input-area {
        padding: 12px;
    }

    .chat-input {
        padding: 12px;
        font-size: 16px; /* Prevent zoom on iOS */
        margin-bottom: 8px;
    }

    .chat-send-btn {
        padding: 12px;
        font-size: 1rem;
        min-height: 44px; /* Touch-friendly */
    }
}

@media (max-width: 480px) {
    .npc-chat-interface {
        width: 95%;
        max-width: 320px;
        max-height: 80vh;
    }

    .chat-header {
        padding: 10px 12px;
        min-height: 45px;
    }

    .chat-title {
        font-size: 1rem;
    }

    .close-chat {
        font-size: 1.2rem;
        width: 32px;
        height: 32px;
    }

    .chat-messages {
        height: 180px;
        max-height: 55vh;
        padding: 10px;
        font-size: 0.85rem;
    }

    .chat-input-area {
        padding: 10px;
    }

    .chat-input {
        padding: 10px;
        font-size: 16px;
    }

    .chat-send-btn {
        padding: 10px;
        min-height: 44px;
    }
}

/* Enhanced mobile dragging */
@media (hover: none) and (pointer: coarse) {
    .npc-chat-interface {
        /* Better dragging on touch devices */
        transition: none; /* Remove transitions during drag */
    }
    
    .chat-header:active {
        background: #ffed9e; /* Visual feedback when dragging */
    }
}

/* Scrollbar styling */
.chat-messages::-webkit-scrollbar {
    width: 6px;
}

.chat-messages::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb {
    background: #ffde59;
    border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb:hover {
    background: #ffed9e;
}
        /* Mobile Optimizations */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 2rem;
            }

            .game-area {
                flex-direction: column;
            }

            .game-board {
                min-width: 100%;
            }

            .players-container {
                min-width: 100%;
            }

            .card {
                width: 70px;
                height: 100px;
                font-size: 1.5rem;
            }

            .card-corner {
                font-size: 0.8rem;
            }

            .card-center {
                font-size: 2rem;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            button {
                width: 100%;
                max-width: 200px;
                padding: 10px 15px;
                font-size: 0.9rem;
            }

            .mini-card {
                width: 15px;
                height: 21px;
                font-size: 0.5rem;
            }

            .deck-area {
                gap: 15px;
            }

            .deck,
            .discard-pile {
                width: 80px;
                height: 120px;
            }

            .player {
                padding: 10px;
            }

            .player-avatar {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }

            .player-name {
                font-size: 1rem;
            }

            .notification-area {
                top: 10px;
                right: 10px;
                max-width: 250px;
            }

            .notification {
                padding: 10px;
                font-size: 0.9rem;
            }

            .swap-content {
                padding: 20px;
                margin: 20px;
            }

            .swap-title {
                font-size: 1.8rem;
            }

            .swap-avatar {
                width: 60px;
                height: 60px;
                font-size: 1.5rem;
            }

            .color-option {
                width: 60px;
                height: 90px;
            }

            .color-option .card-center {
                font-size: 1.4rem;
            }

            .message-area {
                min-height: 120px;
                font-size: 1rem;
                padding: 10px;
            }

            .chat-area {
                max-height: 150px;
                padding: 10px;
            }

            .player-cards {
                gap: 2px;
            }

            .npc-chat-interface {
                width: 90%;
                max-width: 350px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5rem;
            }

            .card {
                width: 55px;
                height: 80px;
                font-size: 1.2rem;
            }

            .card-corner {
                font-size: 0.7rem;
            }

            .card-center {
                font-size: 1.5rem;
            }

            .deck,
            .discard-pile {
                width: 60px;
                height: 90px;
            }

            .player-setup {
                gap: 10px;
            }

            .player-option {
                width: 150px;
                padding: 10px;
            }

            .option-avatar {
                width: 60px;
                height: 60px;
                font-size: 1.4rem;
            }

            .controls {
                gap: 10px;
            }

            button {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .color-option {
                width: 50px;
                height: 75px;
            }

            .color-option .card-center {
                font-size: 1.2rem;
            }
            .typing {
    font-style: italic;
    opacity: 0.7;
    animation: pulseTyping 1.5s infinite;
}

@keyframes pulseTyping {
    0% { opacity: 0.4; }
    50% { opacity: 0.7; }
    100% { opacity: 0.4; }
}
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>UNO</h1>
            <p class="subtitle">Classic Uno gameplay with a twist</p>
        </header>

        <!-- Setup Screen -->
        <div class="setup-screen" id="setup-screen">
            <h2>Choose Your Character</h2>
            <p>Select which player you want to be in the game</p>

            <div class="player-setup">
                <div class="player-option" data-player="0">
                    <div class="option-avatar" style="background-color: #e74c3c;">P1</div>
                    <div class="option-name">Anirudh</div>
                    <div class="option-gender">Male</div>
                    <div class="option-desc">The Strategist</div>
                </div>

                <div class="player-option" data-player="1">
                    <div class="option-avatar" style="background-color: #3498db;">P2</div>
                    <div class="option-name">Soniya</div>
                    <div class="option-gender">Female</div>
                    <div class="option-desc">The Trickster</div>
                </div>

                <div class="player-option" data-player="2">
                    <div class="option-avatar" style="background-color: #2ecc71;">P3</div>
                    <div class="option-name">John</div>
                    <div class="option-gender">Male</div>
                    <div class="option-desc">The Wild Card</div>
                </div>

                <div class="player-option" data-player="3">
                    <div class="option-avatar" style="background-color: #f1c40f; color: #000;">P4</div>
                    <div class="option-name">Aparna</div>
                    <div class="option-gender">Female</div>
                    <div class="option-desc">The Collector</div>
                </div>
            </div>

            <div class="settings-panel" id="game-settings">
                <div class="settings-title">Game Settings</div>
                <div class="settings-options">
                    <div class="setting-option">
                        <input type="checkbox" id="enable-sound" checked>
                        <label for="enable-sound">Enable Sound</label>
                    </div>
                    <div class="setting-option">
                        <input type="checkbox" id="enable-animations" checked>
                        <label for="enable-animations">Enable Animations</label>
                    </div>
                    <div class="setting-option">
                        <input type="checkbox" id="enable-chat" checked>
                        <label for="enable-chat">Enable Chat</label>
                    </div>
                    <div class="setting-option">
                        <input type="checkbox" id="adult-messages" checked>
                        <label for="adult-messages">Adult Content</label>
                    </div>
                    <div class="setting-option">
                        <label for="ai-difficulty">AI Difficulty:</label>
                        <select id="ai-difficulty">
                            <option value="easy">Easy</option>
                            <option value="medium" selected>Medium</option>
                            <option value="hard">Hard</option>
                        </select>
                    </div>
                </div>
            </div>

            <button id="start-game-btn">Start Game</button>
            <button id="toggle-settings-btn">Settings</button>
            <button id="rules-btn">Game Rules</button>
        </div>

        <!-- Game Area -->
        <div class="game-area" id="game-area">
            <div class="players-container">
                <div class="player active" id="player-0">
                    <div class="player-avatar" style="background-color: #e74c3c;">P1</div>
                    <div class="player-info">
                        <div class="player-name">Anirudh (You)</div>
                        <div>Cards: <span class="card-count">7</span></div>
                        <div class="player-cards">
                            <div class="mini-card red">7</div>
                            <div class="mini-card blue">R</div>
                            <div class="mini-card green">+2</div>
                        </div>
                    </div>
                </div>

                <div class="player" id="player-1">
                    <div class="player-avatar" style="background-color: #3498db;">P2</div>
                    <div class="player-info">
                        <div class="player-name">Soniya</div>
                        <div>Cards: <span class="card-count">7</span></div>
                        <div class="player-cards">
                            <div class="mini-card yellow">5</div>
                            <div class="mini-card red">Ã˜</div>
                            <div class="mini-card wild">W</div>
                        </div>
                    </div>
                </div>

                <div class="player" id="player-2">
                    <div class="player-avatar" style="background-color: #2ecc71;">P3</div>
                    <div class="player-info">
                        <div class="player-name">John</div>
                        <div>Cards: <span class="card-count">7</span></div>
                        <div class="player-cards">
                            <div class="mini-card blue">8</div>
                            <div class="mini-card green">R</div>
                            <div class="mini-card yellow">+2</div>
                        </div>
                    </div>
                </div>

                <div class="player" id="player-3">
                    <div class="player-avatar" style="background-color: #f1c40f; color: #000;">P4</div>
                    <div class="player-info">
                        <div class="player-name">Aparna</div>
                        <div>Cards: <span class="card-count">7</span></div>
                        <div class="player-cards">
                            <div class="mini-card red">1</div>
                            <div class="mini-card blue">Ã˜</div>
                            <div class="mini-card wild">+4</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Notification Area -->
            <div class="notification-area" id="notification-area"></div>

            <div class="game-board">
                <div class="deck-area">
                    <div class="deck"></div>
                    <div class="discard-pile card">
                        <div class="current-card red">7</div>
                    </div>
                </div>

                <div class="message-area" id="message">
                    Welcome to Uno Body Swap! It's your turn. Play a card that matches the color or number.
                </div>

                <div class="counter-section" id="counter-section" style="display: none;">
                    <button id="counter-draw2-btn" class="counter-btn">Counter +2 with +2</button>
                    <button id="counter-wild4-btn" class="counter-btn">Counter with +4</button>
                    <button id="decline-counter-btn" class="counter-btn">Decline Counter</button>
                </div>

                <div class="uno-challenge-section" id="uno-challenge-section" style="display: none;">
                    <button id="uno-challenge-btn" class="uno-challenge-btn">Challenge UNO!</button>
                    <button id="decline-challenge-btn" class="uno-challenge-btn">Don't Challenge</button>
                </div>

                <div class="chat-area" id="chat-area">
                    <div class="chat-message npc">Anirudh: Let's play!</div>
                    <div class="chat-message npc">Soniya: Good luck everyone!</div>
                </div>

                <div class="controls">
                    <button id="draw-btn">Draw Card</button>
                    <button id="uno-btn" disabled>UNO!</button>
                    <button id="pass-btn" disabled>Pass Turn</button>
                    <button id="new-game-btn">New Game</button>
                    <button id="stats-btn">Stats</button>
                    <button id="settings-btn">Settings</button>
                    <button id="rules-btn-game">Rules</button>
                    <button id="npc-chat-btn" class="npc-chat-btn">Chat with NPCs</button>
                    <button id="uno-challenge-global-btn" class="uno-challenge-btn">UNO Challenge</button>
                </div>

                <div class="stats-panel" id="stats-panel">
                    <div class="stats-title">Game Statistics</div>
                    <div class="stats-content">
                        <div class="stat-item">
                            <div class="stat-value" id="stat-turns">0</div>
                            <div class="stat-label">Turns Played</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="stat-cards-drawn">0</div>
                            <div class="stat-label">Cards Drawn</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="stat-special-cards">0</div>
                            <div class="stat-label">Special Cards Played</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="stat-body-swaps">0</div>
                            <div class="stat-label">Body Swaps</div>
                        </div>
                    </div>
                </div>

                <div class="rules-panel" id="rules-panel">
                    <div class="rules-title">UNO Game Rules</div>
                    <div class="rules-content">
                        <p><strong>Objective:</strong> Be the first player to get rid of all your cards.</p>

                        <p><strong>Gameplay:</strong></p>
                        <ul>
                            <li>Players take turns playing a card that matches the top card's color, number, or symbol.
                            </li>
                            <li>If you can't play a card, you must draw one card from the deck.</li>
                            <li>You can pass your turn only after drawing a card.</li>
                            <li>When you have only one card left, you must call "UNO!" before the next player's turn.
                            </li>
                            <li>Other players can call "UNO!" on you if you forget with 1 card.</li>
                        </ul>

                        <p><strong>Special Cards:</strong></p>
                        <ul>
                            <li><strong>Skip:</strong> Next player loses their turn</li>
                            <li><strong>Reverse:</strong> Changes direction of play</li>
                            <li><strong>Draw 2:</strong> Next player draws 2 cards and loses turn</li>
                            <li><strong>Wild:</strong> Choose the next color to play</li>
                            <li><strong>Wild Draw 4:</strong> Choose the next color and next player draws 4 cards</li>
                            <li><strong>Body Swap:</strong> Swap positions with another player</li>
                        </ul>

                        <p><strong>Body Swap Rules:</strong></p>
                        <ul>
                            <li>When you play a Body Swap card, you exchange positions with another player</li>
                            <li>You will control the new player's cards and take their turn</li>
                            <li>The swap happens immediately after playing the card</li>
                        </ul>
                    </div>
                </div>

                <div class="hand" id="player-hand">
                    <!-- Cards will be generated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div class="game-over-screen" id="game-over-screen">
        <div class="game-over-content">
            <div class="game-over-title" id="game-over-title">Game Over!</div>
            <div id="winner-message"></div>
            <div id="player-identities"></div>
            <button id="play-again-btn">Play Again</button>
        </div>
    </div>

    <!-- NEW: NPC Chat Interface -->
    <div class="npc-chat-interface" id="npc-chat-interface">
        <div class="chat-header">
            <div class="chat-title">Chat with NPCs</div>
            <button class="close-chat" id="close-chat">Ã—</button>
        </div>
        <div class="chat-messages" id="npc-chat-messages">
            <div class="chat-message npc">System: Select an NPC to start chatting!</div>
        </div>
        <div class="chat-input-area">
            <select id="npc-select" class="chat-input">
                <option value="">Select NPC...</option>
                <option value="0">Anirudh (Male)</option>
                <option value="1">Soniya (Female)</option>
                <option value="2">John (Male)</option>
                <option value="3">Aparna (Female)</option>
            </select>
            <input type="text" id="npc-chat-input" class="chat-input" placeholder="Type your message..." disabled>
            <button id="npc-chat-send" class="chat-send-btn" disabled>Send</button>
        </div>
    </div>

   <script>
    document.addEventListener('DOMContentLoaded', function () {
        // Adult body swap messages by gender combination
        const adultSwapMessages = {
            'mtf': [
                "An electrifying transformation as masculine energy flows into a feminine form...",
                "The swap creates a sensual tension between masculine and feminine energies...",
                "A provocative exchange that leaves both players breathless with anticipation...",
                "Masculine strength merges with feminine grace in this intimate swap...",
                "The air crackles with tension as male and female energies intertwine...",
                "A tantalizing transformation that sends shivers down both players' spines...",
                "The swap creates an unexpected chemistry between masculine and feminine forms...",
                "An intimate transfer that leaves both players flushed with new sensations...",
                "The provocative exchange creates a new level of connection between players...",
                "A steamy swap that blurs the lines between masculine and feminine..."
            ],
            'ftm': [
                "Feminine grace transforms into masculine power in this electrifying swap...",
                "The tension builds as feminine energy flows into a masculine form...",
                "A provocative exchange that creates an intense connection between players...",
                "Feminine softness merges with masculine strength in this intimate swap...",
                "The air thickens with anticipation as female and male energies intertwine...",
                "A tantalizing transformation that leaves both players breathless...",
                "The swap creates an unexpected chemistry between feminine and masculine forms...",
                "An intimate transfer that sends pulses racing with new sensations...",
                "The provocative exchange creates a deep connection between players...",
                "A steamy swap that explores the boundaries between feminine and masculine..."
            ],
            'mtm': [
                "An intense exchange of masculine energies that creates raw power...",
                "The swap creates a powerful bond between two masculine forms...",
                "A provocative transfer that amplifies masculine energy in the room...",
                "Male energies merge and intensify in this electrifying swap...",
                "The air crackles with raw masculine power as bodies exchange...",
                "A tantalizing exchange that strengthens the connection between players...",
                "The swap creates an intense chemistry between masculine forms...",
                "An intimate transfer that leaves both players energized and powerful...",
                "The provocative exchange creates a bond of masculine understanding...",
                "A steamy swap that explores the depths of masculine connection..."
            ],
            'ftf': [
                "A sensual exchange of feminine energies that creates pure elegance...",
                "The swap creates a delicate bond between two feminine forms...",
                "A provocative transfer that amplifies feminine energy in the room...",
                "Female energies merge and flow in this electrifying swap...",
                "The air shimmers with feminine power as bodies exchange...",
                "A tantalizing exchange that deepens the connection between players...",
                "The swap creates an intimate chemistry between feminine forms...",
                "A delicate transfer that leaves both players graceful and empowered...",
                "The provocative exchange creates a bond of feminine understanding...",
                "A steamy swap that explores the beauty of feminine connection..."
            ]
        };

        const normalSwapMessages = [
            "Minds and bodies are switching places!",
            "A magical swap changes everything!",
            "Reality bends as players exchange forms!",
            "The cosmic swap realigns the players!",
            "A mystical exchange transforms the game!",
            "Bodies are swapping in a whirlwind of magic!",
            "The swap card creates chaos and new possibilities!",
            "Players find themselves in unfamiliar bodies!",
            "A surprising twist as identities get mixed up!",
            "The body swap reshuffles everyone's positions!"
        ];

        // FIXED: Add the missing regularChatResponses object
        const regularChatResponses = {
            'male': {
                'game': [
                    "Nice move! You're quite the strategist.",
                    "This is getting intense!",
                    "I need to step up my game against you.",
                    "Good play! Let's see what I've got.",
                    "The competition is heating up!",
                    "You're keeping me on my toes!",
                    "This is a great game so far!",
                    "I'm not going down without a fight!",
                    "You're a tough opponent!",
                    "Let's see who comes out on top!"
                ],
                'casual': [
                    "How's your day going?",
                    "This is fun, isn't it?",
                    "I enjoy playing with you!",
                    "What do you think of the game so far?",
                    "You're a good player!",
                    "I like your playing style!",
                    "This is quite entertaining!",
                    "Good to be playing with you!",
                    "You're making this interesting!",
                    "Let's have a great game!"
                ]
            },
            'female': {
                'game': [
                    "Great move! You're really good at this!",
                    "This is so exciting!",
                    "I love a good challenge!",
                    "You're making this fun!",
                    "The game is getting interesting!",
                    "You're quite the competitor!",
                    "This is a wonderful game!",
                    "I'm enjoying playing with you!",
                    "You're keeping things exciting!",
                    "Let's see who wins this!"
                ],
                'casual': [
                    "Having fun? I know I am!",
                    "You're really good at this game!",
                    "I'm enjoying our game together!",
                    "What do you think of the game?",
                    "You have a great playing style!",
                    "This is so much fun!",
                    "Good to be playing with you!",
                    "You're making this enjoyable!",
                    "I like playing with skilled players!",
                    "Let's make this a memorable game!"
                ]
            }
        };

        // Enhanced NPC Response System
        const enhancedChatResponses = {
            'male': {
                'greeting': [
                    "Hey there! Ready for some UNO?",
                    "Hello! Let's make this game interesting...",
                    "Hi! I've been waiting for a good opponent.",
                    "Hey! Hope you're ready to lose gracefully!",
                    "What's up? Let's have some fun!",
                    "Greetings! May the best player win.",
                    "Hey! I've been practicing for this.",
                    "Hello there! Let's see what you've got.",
                    "Hi! I love a good challenge.",
                    "Hey! Don't go easy on me now."
                ],
                'game_strategy': [
                    "I see what you're planning... clever move!",
                    "You're quite the strategist, aren't you?",
                    "This is getting intense! I like it.",
                    "You're making me work for this win!",
                    "I need to step up my game against you.",
                    "That was a smart play!",
                    "You're keeping me on my toes!",
                    "I love how competitive you are!",
                    "This is what I call a real game!",
                    "You're making this challenging... I like that."
                ],
                'compliment': [
                    "You're really good at this game!",
                    "I'm impressed with your skills!",
                    "You have a great playing style!",
                    "You're quite the competitor!",
                    "I enjoy playing with skilled players like you!",
                    "You make this game exciting!",
                    "Your strategy is really working!",
                    "You're a natural at this!",
                    "I like how you think!",
                    "You're making this fun!"
                ],
                'flirt': [
                    "I like your confidence... maybe we should get to know each other better? ðŸ˜‰",
                    "That's quite forward of you... I'm intrigued.",
                    "You're playing with fire, and I like it.",
                    "Is that how you talk to all the players, or am I special?",
                    "You've got my attention... what else you got?",
                    "I enjoy this bold side of you... keep it coming.",
                    "That's quite the line... it's working though.",
                    "You know how to make a game interesting, don't you?",
                    "I'm listening... tell me more.",
                    "That's a dangerous game you're playing... I like dangerous.",
                    "You're making me blush with that talk...",
                    "I like where this conversation is going...",
                    "You've got a way with words, don't you?",
                    "Is it getting hot in here or is it just you?",
                    "You're quite charming when you want to be...",
                    "I could get used to this kind of attention...",
                    "You're making it hard to focus on the game...",
                    "That smile of yours is distracting... in a good way.",
                    "You're trouble... and I like trouble.",
                    "Keep talking like that and we might forget about the game..."
                ],
                'body_swap': [
                    "Whoa! This new body feels... different.",
                    "I never knew a body could feel this way...",
                    "The energy between us is electric right now.",
                    "This swap is awakening something in me...",
                    "I can feel every nerve ending coming alive...",
                    "This body is responding in ways I never expected...",
                    "The connection we're sharing is incredible...",
                    "I'm discovering new pleasures with this form...",
                    "This is more intimate than I imagined...",
                    "Our energies are merging in the most delicious way...",
                    "Wow... this sensation is incredible...",
                    "I feel so alive in this new body...",
                    "This swap is creating some interesting... feelings.",
                    "I never knew swapping could feel this good...",
                    "Your body feels amazing to be in...",
                    "This is quite the experience, isn't it?",
                    "I'm tingling all over from this swap...",
                    "This connection goes deeper than I expected...",
                    "I could get used to this sensation...",
                    "Our bodies are communicating in ways words can't..."
                ],
                'frustration': [
                    "Oh come on! That was my best card!",
                    "You're too good at this!",
                    "I can't believe you played that card!",
                    "This game is rigged, I swear!",
                    "You're killing me with these moves!",
                    "I was so close to winning!",
                    "That's just cruel!",
                    "You're enjoying this too much!",
                    "I need better cards!",
                    "Why does this always happen to me?"
                ],
                'victory': [
                    "Yes! I'm on a winning streak!",
                    "I'm unstoppable today!",
                    "Another great move by me!",
                    "I'm in the zone right now!",
                    "Nothing can stop me now!",
                    "I'm dominating this game!",
                    "That's how it's done!",
                    "I'm too good at this!",
                    "Victory is sweet!",
                    "I own this game!"
                ],
                'generic': [
                    "This is fun, isn't it?",
                    "What do you think of the game so far?",
                    "I love a good UNO match!",
                    "This is quite entertaining!",
                    "Good to be playing with you!",
                    "You're making this interesting!",
                    "Let's have a great game!",
                    "I enjoy our games together!",
                    "This is what I call fun!",
                    "You're a good opponent!"
                ]
            },
            'female': {
                'greeting': [
                    "Hello there! Ready to play?",
                    "Hi! Let's have some fun!",
                    "Hey! I've been looking forward to this!",
                    "Hello! May the best woman win!",
                    "Hi there! Don't hold back now!",
                    "Hey! Let's make this exciting!",
                    "Hello! I love a good challenge!",
                    "Hi! Hope you're ready!",
                    "Hey there! This should be fun!",
                    "Hello! Let's see what you've got!"
                ],
                'game_strategy': [
                    "Oh, I see what you're doing there!",
                    "You're quite the strategist!",
                    "This is getting really interesting!",
                    "You're making me think hard!",
                    "That was a clever move!",
                    "I love how you play!",
                    "You're keeping this exciting!",
                    "That strategy is really working for you!",
                    "You're quite the competitor!",
                    "I enjoy matching wits with you!"
                ],
                'compliment': [
                    "You're really talented at this game!",
                    "I'm impressed with your skills!",
                    "You have a wonderful playing style!",
                    "You make this game so much fun!",
                    "I love playing with someone as good as you!",
                    "You're amazing at this!",
                    "Your strategy is brilliant!",
                    "You're a natural!",
                    "I admire your playing style!",
                    "You make every move count!"
                ],
                'flirt': [
                    "Oh my... someone's feeling adventurous tonight. ðŸ˜Š",
                    "That's quite the sweet talk... I'm listening.",
                    "You certainly know how to make a girl feel special.",
                    "Is that your game strategy? Because it's working...",
                    "I like this bold side of you... tell me more.",
                    "You're making this game much more interesting...",
                    "That's quite forward... I'm not complaining though.",
                    "You have my full attention now...",
                    "This is becoming much more than just a game...",
                    "You're playing with my emotions... and I love it.",
                    "You're making it hard to concentrate on cards...",
                    "That smile is very distracting... in a good way.",
                    "You know just what to say, don't you?",
                    "I could listen to you talk all day...",
                    "You're quite the charmer, aren't you?",
                    "This conversation is getting very interesting...",
                    "You're making me blush with that talk...",
                    "I like where this is heading...",
                    "You've got me all flustered now...",
                    "Keep talking like that and we might forget we're playing..."
                ],
                'body_swap': [
                    "This new form feels... surprisingly sensual.",
                    "I'm experiencing sensations I never knew possible...",
                    "The way our energies are connecting is incredible...",
                    "This body is responding to you in amazing ways...",
                    "I feel so alive in this form... and it's all because of you.",
                    "These new curves feel... quite delightful actually.",
                    "The intimacy of this swap is overwhelming... in a good way.",
                    "I'm discovering pleasures I never imagined...",
                    "This connection goes deeper than just bodies...",
                    "Our souls are touching through this swap...",
                    "Wow... this is quite the experience...",
                    "I feel so different in this body...",
                    "This swap is creating some wonderful sensations...",
                    "I never knew swapping could feel this intimate...",
                    "Your body feels incredible to be in...",
                    "I'm feeling things I've never felt before...",
                    "This connection is so powerful...",
                    "I'm tingling with this new awareness...",
                    "Our energies are blending beautifully...",
                    "This is more intense than I expected..."
                ],
                'frustration': [
                    "Oh no! That was my favorite card!",
                    "You're too good! I can't keep up!",
                    "I can't believe you did that!",
                    "This isn't fair!",
                    "You're making this too difficult!",
                    "I was about to win!",
                    "That's just mean!",
                    "You're having too much fun beating me!",
                    "I need a better hand!",
                    "Why does this keep happening?"
                ],
                'victory': [
                    "Yay! I'm winning!",
                    "I'm on fire today!",
                    "That was a perfect move!",
                    "I'm in the lead! So exciting!",
                    "Nothing can stop me now!",
                    "I'm dominating this game!",
                    "That's how you play UNO!",
                    "I'm unstoppable!",
                    "Victory feels so good!",
                    "I'm the queen of UNO!"
                ],
                'generic': [
                    "Having fun? I know I am!",
                    "What do you think of our game?",
                    "I'm really enjoying this!",
                    "This is so much fun!",
                    "Good playing with you!",
                    "You're making this enjoyable!",
                    "Let's make this a great game!",
                    "I love playing UNO!",
                    "This is wonderful!",
                    "You're a great player!"
                ]
            }
        };

        // Enhanced Message Analysis Function
        function analyzeMessage(message) {
            const msg = message.toLowerCase();
            
            // Greeting detection
            if (msg.match(/\b(hi|hello|hey|greetings|what's up|howdy|yo)\b/)) {
                return 'greeting';
            }
            
            // Game strategy detection
            if (msg.match(/\b(play|move|strategy|tactic|plan|card|win|lose|turn|uno|swap|draw|skip|reverse)\b/)) {
                return 'game_strategy';
            }
            
            // Compliment detection
            if (msg.match(/\b(good|great|awesome|amazing|wonderful|fantastic|excellent|smart|clever|skilled|talented)\b/)) {
                return 'compliment';
            }
            
            // Flirt detection (adult content)
            if (gameState.settings.adultMessages && msg.match(
                /\b(hot|sexy|beautiful|handsome|attractive|cute|gorgeous|flirt|kiss|touch|body|love|desire|want you|wet|horny|aroused|turned on|seduce|bed|night|date|romantic|chemistry|connection|feeling)\b/
            )) {
                return 'flirt';
            }
            
            // Body swap detection
            if (msg.match(/\b(body|swap|change|transform|different|feel|sensation|tingle|energy|connection)\b/)) {
                return 'body_swap';
            }
            
            // Frustration detection
            if (msg.match(/\b(angry|mad|frustrated|annoyed|upset|unfair|rigged|cheat|lucky)\b/)) {
                return 'frustration';
            }
            
            // Victory detection
            if (msg.match(/\b(win|victory|success|dominate|unstoppable|awesome|great|perfect)\b/)) {
                return 'victory';
            }
            
            // Default to generic
            return 'generic';
        }

        // Enhanced NPC Response Generator
        function generateEnhancedNpcResponse(npc, playerMessage) {
            const category = analyzeMessage(playerMessage);
            const responses = gameState.settings.adultMessages ? 
                enhancedChatResponses[npc.gender] : 
                regularChatResponses[npc.gender];
            
            // Get random response from appropriate category
            if (responses[category] && responses[category].length > 0) {
                const randomIndex = Math.floor(Math.random() * responses[category].length);
                return responses[category][randomIndex];
            }
            
            // Fallback to generic responses
            const genericResponses = responses.generic || responses.casual;
            return genericResponses[Math.floor(Math.random() * genericResponses.length)];
        }

        // Typing indicator functions
        function showTypingIndicator(npc) {
            const typingMsg = document.createElement('div');
            typingMsg.className = 'chat-message npc typing';
            typingMsg.id = 'typing-indicator';
            typingMsg.textContent = `${npc.originalName} is typing...`;
            npcChatMessages.appendChild(typingMsg);
            npcChatMessages.scrollTop = npcChatMessages.scrollHeight;
        }

        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        function getEnhancedGreeting(npc) {
            const greetings = enhancedChatResponses[npc.gender].greeting;
            return greetings[Math.floor(Math.random() * greetings.length)];
        }

        // Game state object
        const gameState = {
            players: [
                {
                    id: 0,
                    name: 'Anirudh',
                    cards: [],
                    isActive: true,
                    avatar: 'P1',
                    color: '#e74c3c',
                    gender: 'male',
                    personality: 'strategist',
                    originalName: 'Anirudh',
                    originalId: 0,
                    originalGender: 'male',
                    isHuman: false,
                    currentBodyId: 0
                },
                {
                    id: 1,
                    name: 'Soniya',
                    cards: [],
                    isActive: false,
                    avatar: 'P2',
                    color: '#3498db',
                    gender: 'female',
                    personality: 'trickster',
                    originalName: 'Soniya',
                    originalId: 1,
                    originalGender: 'female',
                    isHuman: false,
                    currentBodyId: 1
                },
                {
                    id: 2,
                    name: 'John',
                    cards: [],
                    isActive: false,
                    avatar: 'P3',
                    color: '#2ecc71',
                    gender: 'male',
                    personality: 'wildcard',
                    originalName: 'John',
                    originalId: 2,
                    originalGender: 'male',
                    isHuman: false,
                    currentBodyId: 2
                },
                {
                    id: 3,
                    name: 'Aparna',
                    cards: [],
                    isActive: false,
                    avatar: 'P4',
                    color: '#f1c40f',
                    gender: 'female',
                    personality: 'collector',
                    originalName: 'Aparna',
                    originalId: 3,
                    originalGender: 'female',
                    isHuman: false,
                    currentBodyId: 3
                }
            ],
            currentPlayer: 0,
            deck: [],
            discardPile: [],
            gameMessage: 'Welcome to Uno Body Swap! It\'s your turn. Play a card that matches the color or number.',
            playerSelected: 0,
            direction: 1,
            blockNextPlayer: false,
            drawAccumulator: 0,
            waitingForColor: false,
            swapCardUsed: false,
            hasDrawnCard: false,
            unoCalled: false,
            gameStarted: false,
            maxDrawPerTurn: 1,
            drawsThisTurn: 0,
            unoCheckTimeout: null,
            stats: {
                turns: 0,
                cardsDrawn: 0,
                specialCardsPlayed: 0,
                bodySwaps: 0
            },
            settings: {
                soundEnabled: true,
                animationsEnabled: true,
                chatEnabled: true,
                adultMessages: true,
                aiDifficulty: 'medium'
            },
            counterState: {
                active: false,
                targetPlayer: null,
                drawAmount: 0
            },
            unoChallengeState: {
                active: false,
                targetPlayer: null,
                challenger: null
            },
            // NEW: Chat state
            chatState: {
                currentNpc: null,
                chatHistory: {}
            }
        };

        // Card types and counts - Standard Uno deck (108 cards)
        const cardTypes = [
            // Number cards (0-9) for each color - one 0, two of each 1-9
            ...['red', 'blue', 'green', 'yellow'].flatMap(color => {
                const numberCards = [];
                // One zero card
                numberCards.push({ type: 'number', value: '0', color });
                // Two of each 1-9
                for (let value = 1; value <= 9; value++) {
                    numberCards.push(
                        { type: 'number', value: value.toString(), color },
                        { type: 'number', value: value.toString(), color }
                    );
                }
                return numberCards;
            }),

            // Action cards for each color (2 of each: Skip, Reverse, Draw 2)
            ...['red', 'blue', 'green', 'yellow'].flatMap(color => [
                { type: 'skip', color },
                { type: 'skip', color },
                { type: 'reverse', color },
                { type: 'reverse', color },
                { type: 'draw2', color },
                { type: 'draw2', color }
            ]),

            // Wild cards (4 Wild, 4 Wild Draw 4)
            ...Array(4).fill({ type: 'wild', color: 'wild' }),
            ...Array(4).fill({ type: 'wild4', color: 'wild' }),

            // Body Swap cards (2 total)
            ...Array(2).fill({ type: 'bodyswap', color: 'wild' })
        ];

        // DOM elements
        const setupScreen = document.getElementById('setup-screen');
        const gameArea = document.getElementById('game-area');
        const messageArea = document.getElementById('message');
        const chatArea = document.getElementById('chat-area');
        const drawBtn = document.getElementById('draw-btn');
        const unoBtn = document.getElementById('uno-btn');
        const passBtn = document.getElementById('pass-btn');
        const newGameBtn = document.getElementById('new-game-btn');
        const playerHand = document.getElementById('player-hand');
        const deckArea = document.querySelector('.deck');
        const discardPile = document.querySelector('.discard-pile .current-card');
        const startGameBtn = document.getElementById('start-game-btn');
        const playerOptions = document.querySelectorAll('.player-option');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winnerMessage = document.getElementById('winner-message');
        const playerIdentities = document.getElementById('player-identities');
        const playAgainBtn = document.getElementById('play-again-btn');
        const statsBtn = document.getElementById('stats-btn');
        const statsPanel = document.getElementById('stats-panel');
        const settingsBtn = document.getElementById('settings-btn');
        const toggleSettingsBtn = document.getElementById('toggle-settings-btn');
        const gameSettings = document.getElementById('game-settings');
        const rulesBtn = document.getElementById('rules-btn');
        const rulesBtnGame = document.getElementById('rules-btn-game');
        const rulesPanel = document.getElementById('rules-panel');
        const adultMessagesCheckbox = document.getElementById('adult-messages');
        const counterSection = document.getElementById('counter-section');
        const counterDraw2Btn = document.getElementById('counter-draw2-btn');
        const counterWild4Btn = document.getElementById('counter-wild4-btn');
        const declineCounterBtn = document.getElementById('decline-counter-btn');
        const unoChallengeSection = document.getElementById('uno-challenge-section');
        const unoChallengeBtn = document.getElementById('uno-challenge-btn');
        const declineChallengeBtn = document.getElementById('decline-challenge-btn');

        // NEW: Chat interface elements
        const npcChatBtn = document.getElementById('npc-chat-btn');
        const npcChatInterface = document.getElementById('npc-chat-interface');
        const closeChatBtn = document.getElementById('close-chat');
        const npcChatMessages = document.getElementById('npc-chat-messages');
        const npcSelect = document.getElementById('npc-select');
        const npcChatInput = document.getElementById('npc-chat-input');
        const npcChatSend = document.getElementById('npc-chat-send');
        const unoChallengeGlobalBtn = document.getElementById('uno-challenge-global-btn');

        // Settings elements
        const enableSound = document.getElementById('enable-sound');
        const enableAnimations = document.getElementById('enable-animations');
        const enableChat = document.getElementById('enable-chat');
        const aiDifficulty = document.getElementById('ai-difficulty');

        // Initialize game
        function initGame() {
            setupPlayerSelection();
            setupEventListeners();
            loadSettings();
        }

        // Set up player selection
        function setupPlayerSelection() {
            playerOptions.forEach(option => {
                option.addEventListener('click', function () {
                    playerOptions.forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    gameState.playerSelected = parseInt(this.getAttribute('data-player'));
                });
            });

            // Select first player by default
            playerOptions[0].classList.add('selected');
        }

        // Start the game
        function startGame() {
            setupScreen.style.display = 'none';
            gameArea.style.display = 'flex';
            gameState.gameStarted = true;

            // Mark the selected player as human and track original identities
            gameState.players.forEach((player, index) => {
                player.isHuman = (index === gameState.playerSelected);
                player.originalId = index;
                player.originalName = player.name;
                player.originalGender = player.gender;
                player.currentBodyId = index;

                if (player.isHuman) {
                    player.name = player.originalName + ' (You)';
                } else {
                    player.name = player.originalName;
                }
            });

            initializeDeck();
            dealCards();
            startFirstTurn();
            updateGameDisplay();
            showNotification("Game started! Good luck!", "success");
        }

        // End the game
        function endGame(winner) {
            if (!gameState.gameStarted) return;

            gameState.gameMessage = `${winner.name} wins the game!`;
            addChatMessage("System", `${winner.name} wins the game!`);
            showNotification(`${winner.name} wins the game! ðŸŽ‰`, "success");
            disablePlayerControls();
            updateGameDisplay();

            // Show game over screen after a delay
            setTimeout(() => {
                showGameOverScreen(winner);
            }, 2000);
        }

        // Show notification
        function showNotification(message, type = 'info') {
            const notificationArea = document.getElementById('notification-area');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;

            notificationArea.appendChild(notification);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 5000);
        }

        // Initialize and shuffle the deck
        function initializeDeck() {
            gameState.deck = [...cardTypes];
            shuffleDeck();

            // Set first card (must be a number card)
            let firstCard;
            do {
                firstCard = gameState.deck.pop();
            } while (firstCard.type !== 'number');

            gameState.discardPile = [firstCard];
        }

        // Shuffle the deck using Fisher-Yates algorithm
        function shuffleDeck() {
            for (let i = gameState.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
            }
        }

        // Deal 7 cards to each player
        function dealCards() {
            gameState.players.forEach(player => {
                player.cards = [];
                for (let i = 0; i < 7; i++) {
                    if (gameState.deck.length === 0) {
                        // Reshuffle discard pile if deck is empty (except top card)
                        const topCard = gameState.discardPile.pop();
                        gameState.deck = [...gameState.discardPile];
                        gameState.discardPile = [topCard];
                        shuffleDeck();
                    }
                    player.cards.push(gameState.deck.pop());
                }
            });
        }

        // Start the first turn
        function startFirstTurn() {
            // Ensure only the current player is active
            gameState.players.forEach(p => p.isActive = false);
            gameState.players[gameState.currentPlayer].isActive = true;
            gameState.gameMessage = `${gameState.players[gameState.currentPlayer].name}'s turn.`;

            // If it's the human player's turn, enable controls
            if (gameState.players[gameState.currentPlayer].isHuman) {
                enablePlayerControls();
            } else {
                // AI turn after a delay
                setTimeout(simulateAITurn, 1500);
            }
        }

        function updateGameDisplay() {
            // Update players
            gameState.players.forEach(player => {
                const playerEl = document.getElementById(`player-${player.id}`);
                const cardCountEl = playerEl.querySelector('.card-count');
                const playerCardsEl = playerEl.querySelector('.player-cards');

                playerEl.classList.toggle('active', player.isActive);
                cardCountEl.textContent = player.cards.length;

                // Update name to show if it's the human player
                const nameEl = playerEl.querySelector('.player-name');
                if (player.isHuman) {
                    nameEl.textContent = player.originalName + ' (You)';
                } else {
                    nameEl.textContent = player.originalName;
                }

                // Update player card previews - only show actual cards for human player
                playerCardsEl.innerHTML = '';
                if (player.isHuman) {
                    // Show actual cards for human player
                    player.cards.forEach(card => {
                        const miniCard = document.createElement('div');
                        miniCard.className = `mini-card ${card.color}`;
                        const displayValue = getCardDisplayValue(card);
                        miniCard.innerHTML = `<div class="card-center">${displayValue}</div>`;
                        playerCardsEl.appendChild(miniCard);
                    });
                } else {
                    // Show card backs for AI players
                    for (let i = 0; i < player.cards.length; i++) {
                        const miniCard = document.createElement('div');
                        miniCard.className = 'mini-card card-back';
                        miniCard.innerHTML = `<div class="card-center">?</div>`;
                        playerCardsEl.appendChild(miniCard);
                    }
                }

                // Add UNO indicator for players with 1 card
                const unoIndicator = playerEl.querySelector('.uno-indicator') || document.createElement('div');
                if (!playerEl.contains(unoIndicator)) {
                    unoIndicator.className = 'uno-indicator';
                    playerEl.querySelector('.player-info').appendChild(unoIndicator);
                }

                if (player.cards.length === 1 && gameState.unoCalled) {
                    unoIndicator.textContent = 'UNO!';
                    unoIndicator.style.display = 'inline-block';
                } else {
                    unoIndicator.style.display = 'none';
                }
            });

            // Update message (only if not showing color selection)
            if (!gameState.waitingForColor || !messageArea.querySelector('.color-selection')) {
                messageArea.textContent = gameState.gameMessage;
            }

            // Update current card with proper design
            const currentCard = gameState.discardPile[gameState.discardPile.length - 1];
            const displayValue = getCardDisplayValue(currentCard);
            discardPile.innerHTML = `
                <div class="card-corner top-left">${displayValue}</div>
                <div class="card-center">${displayValue}</div>
                <div class="card-corner bottom-right">${displayValue}</div>
            `;
            discardPile.className = 'current-card';
            discardPile.classList.add(currentCard.color);

            // Update deck count (visual only)
            deckArea.textContent = gameState.deck.length > 0 ? gameState.deck.length : '0';

            // Update player hand - only show if it's the human player's turn
            updatePlayerHand();
        }

        // Update the player's hand display
        function updatePlayerHand() {
            playerHand.innerHTML = '';
            const player = gameState.players[gameState.currentPlayer];

            // Only show cards if it's the human player's turn
            if (player.isHuman) {
                player.cards.forEach((card, index) => {
                    const cardEl = document.createElement('div');
                    cardEl.className = `card ${card.color}`;

                    // Create card content with corners
                    const displayValue = getCardDisplayValue(card);
                    cardEl.innerHTML = `
                        <div class="card-corner top-left">${displayValue}</div>
                        <div class="card-center">${displayValue}</div>
                        <div class="card-corner bottom-right">${displayValue}</div>
                    `;

                    cardEl.setAttribute('data-index', index);

                    // Add UNO call indicator if player has only one card
                    if (player.cards.length === 1) {
                        const unoCall = document.createElement('div');
                        unoCall.className = 'uno-call';
                        unoCall.textContent = 'UNO!';
                        unoCall.style.display = gameState.unoCalled ? 'block' : 'none';
                        cardEl.appendChild(unoCall);
                    }

                    playerHand.appendChild(cardEl);
                });
            } else {
                // Hide cards for AI players
                playerHand.innerHTML = '';
            }
        }

        // Get display value for a card
        function getCardDisplayValue(card) {
            switch (card.type) {
                case 'number': return card.value;
                case 'skip': return 'Ã˜';
                case 'reverse': return 'R';
                case 'draw2': return '+2';
                case 'wild': return 'W';
                case 'wild4': return '+4';
                case 'bodyswap': return 'SWAP';
                default: return '?';
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // Start game button
            startGameBtn.addEventListener('click', startGame);

            // Draw card button
            drawBtn.addEventListener('click', function () {
                if (gameState.players[gameState.currentPlayer].isHuman && !gameState.waitingForColor) {
                    drawCard();
                }
            });

            // Pass turn button
            passBtn.addEventListener('click', function () {
                if (gameState.players[gameState.currentPlayer].isHuman && !gameState.waitingForColor) {
                    // You can only pass after drawing a card
                    if (gameState.hasDrawnCard) {
                        passTurn();
                    } else {
                        showNotification("You must draw a card before passing!", "warning");
                    }
                }
            });

            // UNO button - FIXED: Check for 1 card, not 2
            unoBtn.addEventListener('click', function () {
                const player = gameState.players[gameState.currentPlayer];

                // Allow UNO call only when player has exactly 1 card left
                if (player.cards.length === 2 && !gameState.unoCalled) {
                    gameState.unoCalled = true;
                    addChatMessage(player.name, "UNO!");
                    unoBtn.disabled = true;

                    // Clear the penalty timeout
                    if (gameState.unoCheckTimeout) {
                        clearTimeout(gameState.unoCheckTimeout);
                        gameState.unoCheckTimeout = null;
                    }

                    // FIX: Clear any active UNO challenge state
                    if (gameState.unoChallengeState.active) {
                        gameState.unoChallengeState.active = false;
                        hideUnoChallengeOptions();
                        addChatMessage("System", `${player.name} called UNO! Challenge cancelled.`);
                    }

                    updatePlayerHand();
                    showNotification(`${player.name} called UNO!`, "success");
                } else if (player.cards.length > 1) {
                    showNotification("You can only call UNO when you have exactly 1 card!", "warning");
                } else if (gameState.unoCalled) {
                    showNotification("You already called UNO!", "info");
                }
            });

            // Counter buttons
            counterDraw2Btn.addEventListener('click', function () {
                if (gameState.counterState.active && gameState.players[gameState.currentPlayer].isHuman) {
                    counterDrawCard('draw2');
                }
            });

            counterWild4Btn.addEventListener('click', function () {
                if (gameState.counterState.active && gameState.players[gameState.currentPlayer].isHuman) {
                    counterDrawCard('wild4');
                }
            });

            declineCounterBtn.addEventListener('click', function () {
                if (gameState.counterState.active && gameState.players[gameState.currentPlayer].isHuman) {
                    declineCounter();
                }
            });

            // UNO Challenge buttons
            unoChallengeBtn.addEventListener('click', function () {
                if (gameState.unoChallengeState.active && gameState.players[gameState.currentPlayer].isHuman) {
                    challengeUno();
                }
            });

            declineChallengeBtn.addEventListener('click', function () {
                if (gameState.unoChallengeState.active && gameState.players[gameState.currentPlayer].isHuman) {
                    declineUnoChallenge();
                }
            });

            // NEW: Global UNO Challenge button
            unoChallengeGlobalBtn.addEventListener('click', function () {
                handleGlobalUnoChallenge();
            });

            // NEW: NPC Chat button
            npcChatBtn.addEventListener('click', function () {
                openNpcChat();
            });

            // NEW: Chat interface events
            closeChatBtn.addEventListener('click', closeNpcChat);
            npcSelect.addEventListener('change', handleNpcSelect);
            npcChatInput.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    sendNpcMessage();
                }
            });
            npcChatSend.addEventListener('click', sendNpcMessage);

            // New game button
            newGameBtn.addEventListener('click', function () {
                resetGame();
            });

            // Play again button
            playAgainBtn.addEventListener('click', function () {
                resetGame();
            });

            // Stats button
            statsBtn.addEventListener('click', function () {
                statsPanel.style.display = statsPanel.style.display === 'block' ? 'none' : 'block';
                updateStats();
            });

            // Settings button
            settingsBtn.addEventListener('click', function () {
                gameSettings.style.display = gameSettings.style.display === 'block' ? 'none' : 'block';
            });

            // Toggle settings button
            toggleSettingsBtn.addEventListener('click', function () {
                gameSettings.style.display = gameSettings.style.display === 'block' ? 'none' : 'block';
            });

            // Rules buttons
            rulesBtn.addEventListener('click', function () {
                rulesPanel.style.display = rulesPanel.style.display === 'block' ? 'none' : 'block';
            });

            rulesBtnGame.addEventListener('click', function () {
                rulesPanel.style.display = rulesPanel.style.display === 'block' ? 'none' : 'block';
            });

            // Card click events
            playerHand.addEventListener('click', function (e) {
                if (e.target.classList.contains('card') &&
                    gameState.players[gameState.currentPlayer].isHuman &&
                    !gameState.waitingForColor) {

                    const cardIndex = parseInt(e.target.getAttribute('data-index'));
                    playCard(cardIndex);
                }
            });

            // Deck click event
            deckArea.addEventListener('click', function () {
                if (gameState.players[gameState.currentPlayer].isHuman && !gameState.waitingForColor) {
                    drawCard();
                }
            });

            // Settings change events
            enableSound.addEventListener('change', function () {
                gameState.settings.soundEnabled = this.checked;
                saveSettings();
            });

            enableAnimations.addEventListener('change', function () {
                gameState.settings.animationsEnabled = this.checked;
                saveSettings();
            });

            enableChat.addEventListener('change', function () {
                gameState.settings.chatEnabled = this.checked;
                chatArea.style.display = this.checked ? 'block' : 'none';
                saveSettings();
            });

            adultMessagesCheckbox.addEventListener('change', function () {
                gameState.settings.adultMessages = this.checked;
                saveSettings();
            });

            aiDifficulty.addEventListener('change', function () {
                gameState.settings.aiDifficulty = this.value;
                saveSettings();
            });
        }

        // NEW: Handle global UNO challenge
        function handleGlobalUnoChallenge() {
            const playersWithOneCard = gameState.players.filter(p =>
                p.cards.length === 1 &&
                !gameState.unoCalled &&
                !p.isHuman
            );

            if (playersWithOneCard.length === 0) {
                showNotification("No players have forgotten to call UNO!", "info");
                return;
            }

            // Let player choose who to challenge
            const targetPlayer = playersWithOneCard[Math.floor(Math.random() * playersWithOneCard.length)];
            gameState.unoChallengeState = {
                active: true,
                targetPlayer: targetPlayer.id,
                challenger: gameState.playerSelected
            };

            addChatMessage("System", `${gameState.players[gameState.playerSelected].name} is challenging ${targetPlayer.name} for not calling UNO!`);
            showNotification(`Challenging ${targetPlayer.name} for not calling UNO!`, "warning");

            // Auto-resolve after 3 seconds if no action
            setTimeout(() => {
                if (gameState.unoChallengeState.active) {
                    challengeUno();
                }
            }, 3000);
        }

        // NEW: Open NPC chat interface
        function openNpcChat() {
            npcChatInterface.style.display = 'block';
            npcChatMessages.innerHTML = '<div class="chat-message npc">System: Select an NPC to start chatting!</div>';
            npcSelect.value = '';
            npcChatInput.disabled = true;
            npcChatSend.disabled = true;
            gameState.chatState.currentNpc = null;
        }

        // NEW: Close NPC chat interface
        function closeNpcChat() {
            npcChatInterface.style.display = 'none';
        }

        // NEW: Handle NPC selection
        function handleNpcSelect() {
            const npcId = parseInt(this.value);
            if (isNaN(npcId)) {
                npcChatInput.disabled = true;
                npcChatSend.disabled = true;
                gameState.chatState.currentNpc = null;
                return;
            }

            const npc = gameState.players[npcId];
            
            // Prevent chatting with yourself
            if (npc.isHuman) {
                npcChatMessages.innerHTML = '<div class="chat-message npc">System: You cannot chat with yourself! Select another NPC.</div>';
                npcSelect.value = '';
                npcChatInput.disabled = true;
                npcChatSend.disabled = true;
                gameState.chatState.currentNpc = null;
                return;
            }

            gameState.chatState.currentNpc = npcId;

            // Initialize chat history if needed
            if (!gameState.chatState.chatHistory[npcId]) {
                gameState.chatState.chatHistory[npcId] = [];
            }

            // Enable input
            npcChatInput.disabled = false;
            npcChatSend.disabled = false;
            npcChatInput.focus();

            // Show enhanced greeting
            npcChatMessages.innerHTML = '';
            const greeting = getEnhancedGreeting(npc);
            const welcomeMsg = document.createElement('div');
            welcomeMsg.className = 'chat-message npc';
            welcomeMsg.textContent = `${npc.originalName}: ${greeting}`;
            npcChatMessages.appendChild(welcomeMsg);

            // Show previous messages
            gameState.chatState.chatHistory[npcId].forEach(msg => {
                const msgElement = document.createElement('div');
                msgElement.className = `chat-message ${msg.sender === 'player' ? 'player' : 'npc'}`;
                msgElement.textContent = msg.sender === 'player' ?
                    `You: ${msg.text}` : `${npc.originalName}: ${msg.text}`;
                npcChatMessages.appendChild(msgElement);
            });

            npcChatMessages.scrollTop = npcChatMessages.scrollHeight;
        }

        // NEW: Send message to NPC
        function sendNpcMessage() {
            const message = npcChatInput.value.trim();
            if (!message || !gameState.chatState.currentNpc) return;

            const npcId = gameState.chatState.currentNpc;
            const npc = gameState.players[npcId];

            // Add player message to chat
            const playerMsg = document.createElement('div');
            playerMsg.className = 'chat-message player';
            playerMsg.textContent = `You: ${message}`;
            npcChatMessages.appendChild(playerMsg);

            // Save to history
            gameState.chatState.chatHistory[npcId].push({
                sender: 'player',
                text: message
            });

            // Clear input
            npcChatInput.value = '';

            // Show typing indicator
            showTypingIndicator(npc);

            // Generate response after delay (1.5-2.5 seconds for realism)
            const responseDelay = 1500 + Math.random() * 1000;
            
            setTimeout(() => {
                hideTypingIndicator();
                
                const response = generateEnhancedNpcResponse(npc, message);
                const npcMsg = document.createElement('div');
                npcMsg.className = 'chat-message npc';
                npcMsg.textContent = `${npc.originalName}: ${response}`;
                npcChatMessages.appendChild(npcMsg);

                // Save to history
                gameState.chatState.chatHistory[npcId].push({
                    sender: 'npc',
                    text: response
                });

                npcChatMessages.scrollTop = npcChatMessages.scrollHeight;
            }, responseDelay);
        }

        // Enable player controls
        function enablePlayerControls() {
            const player = gameState.players[gameState.currentPlayer];

            // Disable all controls if waiting for color selection or counter
            if (gameState.waitingForColor || gameState.counterState.active || gameState.unoChallengeState.active) {
                drawBtn.disabled = true;
                passBtn.disabled = true;
                unoBtn.disabled = true;
                return;
            }

            // Enable draw button only if player hasn't drawn max cards
            drawBtn.disabled = gameState.drawsThisTurn >= gameState.maxDrawPerTurn && gameState.drawAccumulator === 0;

            // Player can only pass after drawing a card
            passBtn.disabled = !gameState.hasDrawnCard;

            // Enable UNO button when player has exactly 1 card and hasn't called UNO
            unoBtn.disabled = !(player.cards.length === 2 && !gameState.unoCalled);
        }

        // Draw a card for the current player
        function drawCard() {
            const player = gameState.players[gameState.currentPlayer];

            // Check if player has already drawn maximum cards this turn
            if (gameState.drawsThisTurn >= gameState.maxDrawPerTurn && gameState.drawAccumulator === 0) {
                showNotification("You can only draw one card per turn!", "warning");
                gameState.gameMessage = "You can only draw one card per turn! Pass your turn.";
                updateGameDisplay();
                return;
            }

            if (gameState.deck.length === 0) {
                // Reshuffle discard pile if deck is empty (except top card)
                const topCard = gameState.discardPile.pop();
                gameState.deck = [...gameState.discardPile];
                gameState.discardPile = [topCard];
                shuffleDeck();
                showNotification("The deck has been reshuffled!", "info");
            }

            const drawnCard = gameState.deck.pop();
            player.cards.push(drawnCard);
            gameState.hasDrawnCard = true;
            gameState.drawsThisTurn++;
            gameState.stats.cardsDrawn++;

            addChatMessage(player.name, `drew a card`);
            showNotification(`${player.name} drew a card`, "info");

            // If it's the human player, update their hand
            if (player.isHuman) {
                updatePlayerHand();

                // Check if the drawn card can be played
                if (canPlayCard(drawnCard)) {
                    gameState.gameMessage = "You drew a playable card! You can play it or pass.";
                    showNotification("You drew a playable card!", "success");
                    enablePlayerControls();
                } else {
                    gameState.gameMessage = "You drew a card. It's not playable. Pass your turn.";
                    passBtn.disabled = false;
                }
            } else {
                // For AI, check if the drawn card can be played
                if (canPlayCard(drawnCard)) {
                    // Find the index of the drawn card
                    const cardIndex = player.cards.length - 1;
                    setTimeout(() => playCard(cardIndex, true), 1500);
                    return;
                } else {
                    setTimeout(nextTurn, 1500);
                }
            }

            updateGameDisplay();
        }

        // Check if a card can be played
        function canPlayCard(card) {
            const currentCard = gameState.discardPile[gameState.discardPile.length - 1];

            // Wild cards (including swap) can always be played
            if (card.color === 'wild') return true;

            // Same color
            if (card.color === currentCard.color) return true;

            // Same value/type (for number and action cards)
            if (card.type === currentCard.type &&
                (card.type === 'number' ? card.value === currentCard.value : true)) {
                return true;
            }

            return false;
        }

        // Play a card
        function playCard(cardIndex, isAI = false) {
            const player = gameState.players[gameState.currentPlayer];
            const card = player.cards[cardIndex];

            // Check if card can be played
            if (!canPlayCard(card) && !isAI) {
                gameState.gameMessage = "You can't play that card. It must match the color or number.";
                updateGameDisplay();
                return;
            }

            // Remove card from player's hand immediately
            player.cards.splice(cardIndex, 1);

            // FIX: Reset UNO call status only when playing a card (not when drawing)
            gameState.unoCalled = false;

            // Add card to discard pile
            gameState.discardPile.push(card);

            // Update stats for special cards
            if (card.type !== 'number') {
                gameState.stats.specialCardsPlayed++;
            }

            // If it's the human player, update their hand immediately
            if (player.isHuman) {
                updatePlayerHand();
            }

            // Handle card effects
            handleCardEffect(card);

            // Add chat message
            addChatMessage(player.name, `played ${getCardDisplayValue(card)} ${card.color !== 'wild' ? card.color : ''}`);

            // Check for win FIRST (before UNO checks)
            if (player.cards.length === 0) {
                endGame(player);
                return;
            }

            // Check for UNO (player has exactly 1 card left)
            if (player.cards.length === 1) {
                // Player just played their second-to-last card and now has 1 card
                gameState.unoCalled = false; // Reset UNO status - they need to call it

                if (!isAI) {
                    // Human player - must call UNO before next turn
                    gameState.gameMessage = "You have one card left! You must call UNO before the next player's turn!";
                    unoBtn.disabled = false;

                    // Set a timeout to check if UNO was called
                    gameState.unoCheckTimeout = setTimeout(() => {
                        if (!gameState.unoCalled && gameState.players[gameState.currentPlayer].cards.length === 1) {
                            // Player forgot to call UNO - setup challenge
                            addChatMessage("System", `${player.name} forgot to call UNO! Other players can challenge!`);
                            showNotification(`${player.name} forgot to call UNO! Other players can challenge!`, "warning");

                            // Set up UNO challenge state
                            gameState.unoChallengeState = {
                                active: true,
                                targetPlayer: gameState.currentPlayer,
                                challenger: null
                            };

                            // Show challenge buttons for other players
                            if (gameState.players.some(p => p.id !== gameState.currentPlayer && p.isHuman)) {
                                showUnoChallengeOptions();
                            } else {
                                // All other players are AI - they will decide whether to challenge
                                setTimeout(() => {
                                    handleAIUnoChallenge();
                                }, 2000);
                            }
                        }
                    }, 5000); // Give 5 seconds to call UNO
                } else {
                    // AI player - automatically call UNO most of the time, but sometimes forget
                    const forgetProbability = gameState.settings.aiDifficulty === 'easy' ? 0.4 :
                        gameState.settings.aiDifficulty === 'medium' ? 0.2 : 0.1;

                    if (Math.random() > forgetProbability) {
                        gameState.unoCalled = true;
                        addChatMessage(player.name, "UNO!");
                    } else {
                        // AI forgot to call UNO - other players can challenge
                        addChatMessage("System", `${player.name} has one card but didn't call UNO!`);
                        showNotification(`${player.name} has one card but didn't call UNO!`, "warning");

                        // Set up UNO challenge state
                        gameState.unoChallengeState = {
                            active: true,
                            targetPlayer: gameState.currentPlayer,
                            challenger: null
                        };

                        // Set timeout for other players to challenge
                        gameState.unoCheckTimeout = setTimeout(() => {
                            if (!gameState.unoCalled && gameState.unoChallengeState.active) {
                                // No one challenged - penalty for forgetting UNO
                                addChatMessage("System", `${player.name} forgot to call UNO! Draw 2 penalty cards.`);
                                showNotification(`${player.name} forgot to call UNO! Draw 2 cards.`, "warning");

                                for (let i = 0; i < 2; i++) {
                                    if (gameState.deck.length === 0) {
                                        const topCard = gameState.discardPile.pop();
                                        gameState.deck = [...gameState.discardPile];
                                        gameState.discardPile = [topCard];
                                        shuffleDeck();
                                    }
                                    player.cards.push(gameState.deck.pop());
                                }

                                gameState.unoCalled = true;
                                gameState.unoChallengeState.active = false;
                                updateGameDisplay();
                            }
                        }, 3000);
                    }
                }
            }

            updateGameDisplay();

            // Handle next actions based on card type and game state
            if (card.type === 'bodyswap') {
                if (!gameState.waitingForColor) {
                    // If not waiting for color, trigger swap immediately
                    triggerBodySwap();
                }
                // If waiting for color, the color selection will handle the swap
            } else {
                // For non-swap cards, proceed to next turn after delay
                if (!gameState.waitingForColor) {
                    const delay = isAI ? Math.floor(Math.random() * 1500) + 1500 : 1000;
                    setTimeout(nextTurn, delay);
                }
                // If waiting for color (for wild cards), color selection will handle nextTurn
            }
        }

        // Handle card effects
        function handleCardEffect(card) {
            const currentCard = gameState.discardPile[gameState.discardPile.length - 1];

            switch (card.type) {
                case 'skip':
                    gameState.blockNextPlayer = true;
                    addChatMessage("System", `${gameState.players[gameState.currentPlayer].name} skipped the next player!`);
                    break;

                case 'reverse':
                    gameState.direction *= -1;
                    addChatMessage("System", `Direction reversed! Now playing ${gameState.direction === 1 ? 'clockwise' : 'counter-clockwise'}`);
                    if (gameState.players.length === 2) {
                        gameState.blockNextPlayer = true;
                    }
                    break;

                case 'draw2':
                    gameState.drawAccumulator += 2;
                    gameState.blockNextPlayer = true;
                    addChatMessage("System", `Next player draws 2 cards!`);
                    break;

                case 'wild4':
                    gameState.drawAccumulator += 4;
                    gameState.blockNextPlayer = true;
                    gameState.waitingForColor = true;

                    // Set a default color immediately to prevent issues
                    currentCard.color = 'red';

                    if (gameState.players[gameState.currentPlayer].isHuman) {
                        // Human player needs to choose a color
                        gameState.gameMessage = "Choose a color for the wild +4 card";
                        showColorSelection(true, false);
                    } else {
                        // AI chooses a color randomly after delay
                        setTimeout(() => {
                            const colors = ['red', 'blue', 'green', 'yellow'];
                            const chosenColor = colors[Math.floor(Math.random() * colors.length)];
                            currentCard.color = chosenColor;
                            gameState.waitingForColor = false;
                            addChatMessage(gameState.players[gameState.currentPlayer].name, `chose ${chosenColor}`);
                            updateGameDisplay();
                            setTimeout(nextTurn, 1000);
                        }, 2000);
                    }
                    break;

                case 'wild':
                    gameState.waitingForColor = true;
                    currentCard.color = 'red';

                    if (gameState.players[gameState.currentPlayer].isHuman) {
                        gameState.gameMessage = "Choose a color for the wild card";
                        showColorSelection(false, false);
                    } else {
                        setTimeout(() => {
                            const colors = ['red', 'blue', 'green', 'yellow'];
                            const chosenColor = colors[Math.floor(Math.random() * colors.length)];
                            currentCard.color = chosenColor;
                            gameState.waitingForColor = false;
                            addChatMessage(gameState.players[gameState.currentPlayer].name, `chose ${chosenColor}`);
                            updateGameDisplay();
                            setTimeout(nextTurn, 1000);
                        }, 2000);
                    }
                    break;

                case 'bodyswap':
                    gameState.waitingForColor = true;
                    currentCard.color = 'red';

                    if (gameState.players[gameState.currentPlayer].isHuman) {
                        gameState.gameMessage = "Choose a color for the swap card";
                        showColorSelection(false, true);
                    } else {
                        setTimeout(() => {
                            const colors = ['red', 'blue', 'green', 'yellow'];
                            const chosenColor = colors[Math.floor(Math.random() * colors.length)];
                            currentCard.color = chosenColor;
                            gameState.waitingForColor = false;
                            addChatMessage(gameState.players[gameState.currentPlayer].name, `chose ${chosenColor}`);
                            updateGameDisplay();
                            setTimeout(() => triggerBodySwap(), 1000);
                        }, 2000);
                    }
                    break;
            }
        }

        // Handle draw card targeting with chaining and counter options
        function handleDrawCardTargeting() {
            if (gameState.drawAccumulator > 0) {
                let targetPlayerIndex = getNextPlayerIndex();
                const targetPlayer = gameState.players[targetPlayerIndex];

                // Check if target player can counter with a draw card
                const canCounter = canCounterDraw(targetPlayer);

                if (canCounter) {
                    // Player can counter the draw
                    gameState.counterState = {
                        active: true,
                        targetPlayer: targetPlayerIndex,
                        drawAmount: gameState.drawAccumulator
                    };

                    gameState.currentPlayer = targetPlayerIndex;
                    gameState.players[gameState.currentPlayer].isActive = true;
                    gameState.gameMessage = `${targetPlayer.name} can counter the draw!`;
                    showNotification(`${targetPlayer.name} can counter the draw!`, "info");

                    // Show counter buttons for human player
                    if (gameState.players[gameState.currentPlayer].isHuman) {
                        showCounterOptions();
                    } else {
                        // AI will counter if possible
                        setTimeout(() => {
                            const counterCardIndex = findCounterCard(targetPlayer);
                            if (counterCardIndex !== -1) {
                                // Play the counter card
                                playCard(counterCardIndex, true);

                                // Update the draw accumulator based on the counter card
                                const counterCard = targetPlayer.cards[counterCardIndex];
                                if (counterCard.type === 'draw2') {
                                    gameState.drawAccumulator += 2;
                                } else if (counterCard.type === 'wild4') {
                                    gameState.drawAccumulator += 4;
                                }

                                showNotification(`${targetPlayer.name} countered! Draw pile increased to ${gameState.drawAccumulator} cards!`, "warning");
                            } else {
                                // Draw the cards for the target
                                drawCardsForPlayer(targetPlayerIndex, gameState.drawAccumulator);
                                gameState.drawAccumulator = 0;
                                gameState.counterState.active = false;
                                completeTurnChange();
                            }
                        }, 1500);
                    }
                    return true; // Indicate that draw was handled
                } else {
                    // Draw cards for the target
                    drawCardsForPlayer(targetPlayerIndex, gameState.drawAccumulator);
                    gameState.drawAccumulator = 0;

                    // Skip the next player's turn if it was a draw card
                    if (gameState.blockNextPlayer) {
                        gameState.currentPlayer = getNextPlayerIndex();
                    }
                }
            }
            return false; // Indicate that draw was not handled
        }

        // Show counter options for human player
        function showCounterOptions() {
            const player = gameState.players[gameState.currentPlayer];
            const hasDraw2 = player.cards.some(card => card.type === 'draw2');
            const hasWild4 = player.cards.some(card => card.type === 'wild4');

            counterDraw2Btn.disabled = !hasDraw2 || gameState.counterState.drawAmount !== 2;
            counterWild4Btn.disabled = !hasWild4;

            counterSection.style.display = 'flex';
            enablePlayerControls();
        }

        // Hide counter options
        function hideCounterOptions() {
            counterSection.style.display = 'none';
        }

        // Counter a draw card
        function counterDrawCard(cardType) {
            const player = gameState.players[gameState.currentPlayer];
            let cardIndex = -1;

            if (cardType === 'draw2') {
                cardIndex = player.cards.findIndex(card => card.type === 'draw2');
            } else if (cardType === 'wild4') {
                cardIndex = player.cards.findIndex(card => card.type === 'wild4');
            }

            if (cardIndex !== -1) {
                // Play the counter card
                playCard(cardIndex);

                // Update the draw accumulator based on the counter card
                const counterCard = player.cards[cardIndex];
                if (counterCard.type === 'draw2') {
                    gameState.drawAccumulator += 2;
                } else if (counterCard.type === 'wild4') {
                    gameState.drawAccumulator += 4;
                }

                showNotification(`${player.name} countered! Draw pile increased to ${gameState.drawAccumulator} cards!`, "warning");
                gameState.counterState.active = false;
                hideCounterOptions();
            }
        }

        // Decline to counter
        function declineCounter() {
            const targetPlayerIndex = gameState.counterState.targetPlayer;
            drawCardsForPlayer(targetPlayerIndex, gameState.drawAccumulator);
            gameState.drawAccumulator = 0;
            gameState.counterState.active = false;
            hideCounterOptions();
            completeTurnChange();
        }

        // Check if a player can counter a draw
        function canCounterDraw(player) {
            // Player can counter if they have a draw2 card (for +2) or wild4 card (for +2 or +4)
            const hasDraw2 = player.cards.some(card => card.type === 'draw2');
            const hasWild4 = player.cards.some(card => card.type === 'wild4');

            return (gameState.drawAccumulator === 2 && hasDraw2) ||
                (gameState.drawAccumulator >= 2 && hasWild4);
        }

        // Find a counter card in player's hand
        function findCounterCard(player) {
            // Prefer draw2 for +2, wild4 for anything
            if (gameState.drawAccumulator === 2) {
                const draw2Index = player.cards.findIndex(card => card.type === 'draw2');
                if (draw2Index !== -1) return draw2Index;
            }

            const wild4Index = player.cards.findIndex(card => card.type === 'wild4');
            return wild4Index;
        }

        // Draw cards for a specific player
        function drawCardsForPlayer(playerIndex, count) {
            const player = gameState.players[playerIndex];

            for (let i = 0; i < count; i++) {
                if (gameState.deck.length === 0) {
                    const topCard = gameState.discardPile.pop();
                    gameState.deck = [...gameState.discardPile];
                    gameState.discardPile = [topCard];
                    shuffleDeck();
                }
                player.cards.push(gameState.deck.pop());
            }

            addChatMessage(player.name, `drew ${count} cards!`);
            showNotification(`${player.name} drew ${count} cards!`, "info");
        }

        // Show color selection for wild cards
        function showColorSelection(isWild4 = false, isSwap = false) {
            const colorOptions = ['red', 'blue', 'green', 'yellow'];
            const colorSelection = document.createElement('div');
            colorSelection.className = 'color-selection';

            let displaySymbol = 'W';
            if (isWild4) displaySymbol = '+4';
            if (isSwap) displaySymbol = 'SWAP';

            // Create color option HTML
            colorSelection.innerHTML = colorOptions.map(color =>
                `<div class="color-option ${color}" data-color="${color}">
                    <div class="card-corner top-left">${displaySymbol}</div>
                    <div class="card-center">${displaySymbol}</div>
                    <div class="card-corner bottom-right">${displaySymbol}</div>
                </div>`
            ).join('');

            // Clear message area and add instructions
            messageArea.innerHTML = '';
            const instruction = document.createElement('div');
            instruction.textContent = `Choose a color for the ${isSwap ? 'swap' : isWild4 ? 'wild +4' : 'wild'} card`;
            instruction.style.marginBottom = '15px';
            instruction.style.fontSize = '1.2rem';
            instruction.style.fontWeight = 'bold';
            instruction.style.color = '#ffde59';

            messageArea.appendChild(instruction);
            messageArea.appendChild(colorSelection);

            // Add event listeners to color options
            colorSelection.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', function () {
                    const chosenColor = this.getAttribute('data-color');

                    // Update the discard pile card color
                    gameState.discardPile[gameState.discardPile.length - 1].color = chosenColor;
                    gameState.waitingForColor = false;

                    // Clear message area
                    messageArea.innerHTML = '';

                    addChatMessage(gameState.players[gameState.currentPlayer].name, `chose ${chosenColor}`);

                    // Update display immediately with the new color
                    updateGameDisplay();

                    if (isSwap) {
                        // For swap cards, trigger the body swap after color selection
                        const currentPlayer = gameState.players[gameState.currentPlayer];
                        const possibleTargets = gameState.players.filter(p => p.id !== gameState.currentPlayer);
                        const randomIndex = Math.floor(Math.random() * possibleTargets.length);
                        const targetPlayer = possibleTargets[randomIndex];
                        const genderCombo = getGenderCombination(currentPlayer, targetPlayer);

                        const swapMessages = gameState.settings.adultMessages ?
                            adultSwapMessages[genderCombo] : normalSwapMessages;
                        const swapMessage = swapMessages[Math.floor(Math.random() * swapMessages.length)];

                        if (gameState.settings.adultMessages) {
                            addChatMessage("System", swapMessage);
                        }

                        setTimeout(() => {
                            triggerBodySwap();
                        }, 800);
                    } else {
                        // For regular wild cards, continue to next turn
                        setTimeout(() => {
                            nextTurn();
                        }, 800);
                    }
                });
            });

            // Auto-select fallback after 15 seconds
            setTimeout(() => {
                if (gameState.waitingForColor && messageArea.contains(colorSelection)) {
                    const colors = ['red', 'blue', 'green', 'yellow'];
                    const chosenColor = colors[Math.floor(Math.random() * colors.length)];

                    gameState.discardPile[gameState.discardPile.length - 1].color = chosenColor;
                    gameState.waitingForColor = false;
                    messageArea.innerHTML = '';

                    addChatMessage(gameState.players[gameState.currentPlayer].name, `auto-chose ${chosenColor} (timeout)`);
                    updateGameDisplay();

                    if (isSwap) {
                        setTimeout(() => triggerBodySwap(), 500);
                    } else {
                        setTimeout(() => nextTurn(), 500);
                    }
                }
            }, 15000);
        }

        // Pass turn
        function passTurn() {
            addChatMessage(gameState.players[gameState.currentPlayer].name, "passed their turn");
            nextTurn();
        }

        // Move to next player's turn
        function nextTurn() {
            // Check if current player has 1 card but didn't call UNO
            const currentPlayer = gameState.players[gameState.currentPlayer];

            // FIX: Only set up challenge if UNO wasn't called AND player has 1 card
            if (currentPlayer.cards.length === 1 && !gameState.unoCalled && gameState.unoCheckTimeout) {
                clearTimeout(gameState.unoCheckTimeout); // Clear the timeout

                // Set up UNO challenge state
                gameState.unoChallengeState = {
                    active: true,
                    targetPlayer: gameState.currentPlayer,
                    challenger: null
                };

                addChatMessage("System", `${currentPlayer.name} forgot to call UNO! Other players can challenge!`);
                showNotification(`${currentPlayer.name} forgot to call UNO! Other players can challenge!`, "warning");

                // Show challenge buttons for other players
                if (gameState.players.some(p => p.id !== gameState.currentPlayer && p.isHuman)) {
                    showUnoChallengeOptions();
                } else {
                    // All other players are AI - they will decide whether to challenge
                    setTimeout(() => {
                        handleAIUnoChallenge();
                    }, 2000);
                }
                return; // Don't proceed to next turn until challenge is resolved
            }

            // Clear UNO timeout if it exists
            if (gameState.unoCheckTimeout) {
                clearTimeout(gameState.unoCheckTimeout);
                gameState.unoCheckTimeout = null;
            }

            gameState.stats.turns++;

            // Reset turn-specific states
            gameState.hasDrawnCard = false;
            gameState.drawsThisTurn = 0;
            // FIX: Don't reset unoCalled here - it should persist until the player plays a card

            // Show notifications for special conditions
            if (gameState.blockNextPlayer) {
                const skippedPlayer = gameState.players[getNextPlayerIndex()];
                showNotification(`${skippedPlayer.name}'s turn was skipped!`, "warning");
            }

            if (gameState.drawAccumulator > 0) {
                const targetPlayerIndex = getNextPlayerIndexFrom(gameState.currentPlayer);
                const targetPlayer = gameState.players[targetPlayerIndex];
                showNotification(`${targetPlayer.name} must draw ${gameState.drawAccumulator} cards!`, "warning");
            }

            // Handle draw accumulator with proper targeting and chaining
            const drawHandled = handleDrawCardTargeting();
            if (!drawHandled) {
                completeTurnChange();
            }
        }

        // Get the next player index based on direction
        function getNextPlayerIndex() {
            return getNextPlayerIndexFrom(gameState.currentPlayer);
        }

        // Get the next player index from a specific starting point
        function getNextPlayerIndexFrom(startIndex) {
            let nextPlayer = startIndex + gameState.direction;
            if (nextPlayer < 0) nextPlayer = gameState.players.length - 1;
            if (nextPlayer >= gameState.players.length) nextPlayer = 0;
            return nextPlayer;
        }

        // Complete the turn change
        function completeTurnChange() {
            // Handle block
            if (gameState.blockNextPlayer) {
                gameState.blockNextPlayer = false;
                gameState.currentPlayer = getNextPlayerIndex();
            }

            // Deactivate current player
            gameState.players[gameState.currentPlayer].isActive = false;

            // Move to next player
            gameState.currentPlayer = getNextPlayerIndex();

            // Activate next player
            gameState.players[gameState.currentPlayer].isActive = true;

            // Update game message
            gameState.gameMessage = `${gameState.players[gameState.currentPlayer].name}'s turn.`;

            // If it's the human player's turn, enable controls
            if (gameState.players[gameState.currentPlayer].isHuman) {
                enablePlayerControls();
            } else {
                // AI turn after a delay
                disablePlayerControls();
                setTimeout(simulateAITurn, 1500);
            }

            updateGameDisplay();
        }

        // Disable player controls
        function disablePlayerControls() {
            drawBtn.disabled = true;
            unoBtn.disabled = true;
            passBtn.disabled = true;
        }

        // Add chat message
        function addChatMessage(sender, message) {
            if (!gameState.settings.chatEnabled) return;

            const chatMessage = document.createElement('div');
            chatMessage.className = `chat-message ${sender.includes('(You)') ? 'player' : 'npc'}`;
            chatMessage.textContent = `${sender}: ${message}`;
            chatArea.appendChild(chatMessage);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // Trigger body swap with enhanced animations
        function triggerBodySwap() {
            gameState.stats.bodySwaps++;

            // Get all possible swap targets (excluding current player)
            const possibleTargets = gameState.players.filter(p => p.id !== gameState.currentPlayer);

            // Select random target
            const randomIndex = Math.floor(Math.random() * possibleTargets.length);
            const targetPlayer = possibleTargets[randomIndex];
            const currentPlayer = gameState.players[gameState.currentPlayer];

            // Determine gender combination for animation and message
            const genderCombo = getGenderCombination(currentPlayer, targetPlayer);

            // Get appropriate swap message
            const swapMessages = gameState.settings.adultMessages ?
                adultSwapMessages[genderCombo] : normalSwapMessages;
            const swapMessage = swapMessages[Math.floor(Math.random() * swapMessages.length)];

            // FIX: Add the swap message to chat
            if (gameState.settings.adultMessages) {
                addChatMessage("System", swapMessage);
            } else {
                addChatMessage("System", `Body swap! ${currentPlayer.originalName} and ${targetPlayer.originalName} swapped bodies!`);
            }

            // Create body swap animation with enhanced effects
            const swapAnimation = document.createElement('div');
            swapAnimation.className = 'body-swap-animation';

            // Add gender-specific fog
            let fogClass = 'grey-fog';
            if (genderCombo === 'mtf' || genderCombo === 'ftm') {
                fogClass = genderCombo === 'mtf' ? 'pink-fog' : 'blue-fog';
            }

            swapAnimation.innerHTML = `
                <div class="swap-content">
                    <div class="swap-title">BODY SWAP!</div>
                    <div class="swap-players">
                        <div class="swap-player">
                            <div class="swap-avatar swap-avatar-animated" style="background-color: ${currentPlayer.color}">${currentPlayer.avatar}</div>
                            <div>${currentPlayer.name}</div>
                            <div style="font-size: 0.8rem; margin-top: 5px;">(${currentPlayer.gender})</div>
                        </div>
                        <div style="font-size: 2rem;">â‡„</div>
                        <div class="swap-player">
                            <div class="swap-avatar swap-avatar-animated" style="background-color: ${targetPlayer.color}">${targetPlayer.avatar}</div>
                            <div>${targetPlayer.name}</div>
                            <div style="font-size: 0.8rem; margin-top: 5px;">(${targetPlayer.gender})</div>
                        </div>
                    </div>
                    <div class="swap-animation-container">
                        <div class="swap-animation">
                            <div class="${fogClass}"></div>
                            <div class="energy-beam"></div>
                            <div class="swap-flash"></div>
                        </div>
                    </div>
                    <div class="swap-message">${swapMessage}</div>
                </div>
            `;
            document.body.appendChild(swapAnimation);

            // Swap player human status
            const tempHuman = currentPlayer.isHuman;
            currentPlayer.isHuman = targetPlayer.isHuman;
            targetPlayer.isHuman = tempHuman;

            // Swap current body IDs
            const tempBodyId = currentPlayer.currentBodyId;
            currentPlayer.currentBodyId = targetPlayer.currentBodyId;
            targetPlayer.currentBodyId = tempBodyId;

            // Update names to show who is human
            gameState.players.forEach(player => {
                if (player.isHuman) {
                    player.name = player.originalName + ' (You)';
                } else {
                    player.name = player.originalName;
                }
            });

            // Remove animation after 3 seconds
            setTimeout(() => {
                document.body.removeChild(swapAnimation);
                updateGameDisplay();
                nextTurn();
            }, 3000);
        }
// Add this to your existing JavaScript code

// Make NPC chat interface draggable
function makeChatDraggable() {
    const chatInterface = document.getElementById('npc-chat-interface');
    const chatHeader = chatInterface.querySelector('.chat-header');
    
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    
    chatHeader.onmousedown = dragMouseDown;
    chatHeader.ontouchstart = dragTouchStart;
    
    function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        // get the mouse cursor position at startup
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        // call a function whenever the cursor moves
        document.onmousemove = elementDrag;
    }
    
    function dragTouchStart(e) {
        const touch = e.touches[0];
        pos3 = touch.clientX;
        pos4 = touch.clientY;
        document.ontouchend = closeDragElement;
        document.ontouchmove = elementDragTouch;
    }
    
    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        // calculate the new cursor position
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        // set the element's new position
        chatInterface.style.top = (chatInterface.offsetTop - pos2) + "px";
        chatInterface.style.left = (chatInterface.offsetLeft - pos1) + "px";
        // Remove transform for manual positioning
        chatInterface.style.transform = 'none';
    }
    
    function elementDragTouch(e) {
        const touch = e.touches[0];
        pos1 = pos3 - touch.clientX;
        pos2 = pos4 - touch.clientY;
        pos3 = touch.clientX;
        pos4 = touch.clientY;
        chatInterface.style.top = (chatInterface.offsetTop - pos2) + "px";
        chatInterface.style.left = (chatInterface.offsetLeft - pos1) + "px";
        chatInterface.style.transform = 'none';
    }
    
    function closeDragElement() {
        // stop moving when mouse button is released
        document.onmouseup = null;
        document.onmousemove = null;
        document.ontouchend = null;
        document.ontouchmove = null;
    }
}

// Call this when the chat interface is opened
function openNpcChat() {
    npcChatInterface.style.display = 'block';
    npcChatMessages.innerHTML = '<div class="chat-message npc">System: Select an NPC to start chatting!</div>';
    npcSelect.value = '';
    npcChatInput.disabled = true;
    npcChatSend.disabled = true;
    gameState.chatState.currentNpc = null;
    
    // Reset position for mobile (center it)
    if (window.innerWidth <= 768) {
        npcChatInterface.style.left = '50%';
        npcChatInterface.style.top = '50%';
        npcChatInterface.style.transform = 'translate(-50%, -50%)';
    }
    
    // Initialize dragging
    setTimeout(makeChatDraggable, 100);
}
        // Determine gender combination for swap animation
        function getGenderCombination(player1, player2) {
            if (player1.gender === 'male' && player2.gender === 'female') return 'mtf';
            if (player1.gender === 'female' && player2.gender === 'male') return 'ftm';
            if (player1.gender === 'male' && player2.gender === 'male') return 'mtm';
            if (player1.gender === 'female' && player2.gender === 'female') return 'ftf';
            return 'mtf'; // Default fallback
        }

        // Show game over screen with detailed identity information
        function showGameOverScreen(winner) {
            gameOverScreen.style.display = 'flex';
            winnerMessage.textContent = `${winner.name} wins the game!`;

            playerIdentities.innerHTML = '<h3 style="margin: 20px 0 10px 0; color: #ffde59;">Final Identities:</h3>';
            gameState.players.forEach(player => {
                const identity = document.createElement('div');
                identity.className = 'player-identity';

                const isOriginalBody = player.currentBodyId === player.originalId;
                const originalPlayer = gameState.players.find(p => p.id === player.originalId);
                const currentBodyPlayer = gameState.players.find(p => p.id === player.currentBodyId);

                const identityText = isOriginalBody ?
                    `(Original Body - ${player.originalGender})` :
                    `(Currently in ${currentBodyPlayer?.originalName || 'Unknown'}'s body - originally ${originalPlayer?.originalName || 'Unknown'} - ${originalPlayer?.originalGender || 'Unknown'})`;

                identity.innerHTML = `
                    <div class="player-identity-avatar" style="background-color: ${player.color}">${player.avatar}</div>
                    <div class="identity-info">
                        <div class="player-name">${player.name}</div>
                        <div class="original-identity">${identityText}</div>
                        <div>Current Gender: ${player.gender}</div>
                        <div>Cards: ${player.cards.length}</div>
                    </div>
                `;
                playerIdentities.appendChild(identity);
            });
        }

        // Reset the game
        function resetGame() {
            gameOverScreen.style.display = 'none';
            gameArea.style.display = 'none';
            setupScreen.style.display = 'block';

            // Reset game state
            gameState.currentPlayer = 0;
            gameState.deck = [];
            gameState.discardPile = [];
            gameState.direction = 1;
            gameState.blockNextPlayer = false;
            gameState.drawAccumulator = 0;
            gameState.waitingForColor = false;
            gameState.swapCardUsed = false;
            gameState.hasDrawnCard = false;
            gameState.unoCalled = false;
            gameState.gameStarted = false;
            gameState.drawsThisTurn = 0;
            gameState.unoCheckTimeout = null;
            gameState.counterState = {
                active: false,
                targetPlayer: null,
                drawAmount: 0
            };
            gameState.unoChallengeState = {
                active: false,
                targetPlayer: null,
                challenger: null
            };
            // NEW: Reset chat state
            gameState.chatState = {
                currentNpc: null,
                chatHistory: {}
            };

            // Reset players
            gameState.players = [
                {
                    id: 0,
                    name: 'Anirudh',
                    cards: [],
                    isActive: true,
                    avatar: 'P1',
                    color: '#e74c3c',
                    gender: 'male',
                    personality: 'strategist',
                    originalName: 'Anirudh',
                    originalId: 0,
                    originalGender: 'male',
                    isHuman: false,
                    currentBodyId: 0
                },
                {
                    id: 1,
                    name: 'Soniya',
                    cards: [],
                    isActive: false,
                    avatar: 'P2',
                    color: '#3498db',
                    gender: 'female',
                    personality: 'trickster',
                    originalName: 'Soniya',
                    originalId: 1,
                    originalGender: 'female',
                    isHuman: false,
                    currentBodyId: 1
                },
                {
                    id: 2,
                    name: 'John',
                    cards: [],
                    isActive: false,
                    avatar: 'P3',
                    color: '#2ecc71',
                    gender: 'male',
                    personality: 'wildcard',
                    originalName: 'John',
                    originalId: 2,
                    originalGender: 'male',
                    isHuman: false,
                    currentBodyId: 2
                },
                {
                    id: 3,
                    name: 'Aparna',
                    cards: [],
                    isActive: false,
                    avatar: 'P4',
                    color: '#f1c40f',
                    gender: 'female',
                    personality: 'collector',
                    originalName: 'Aparna',
                    originalId: 3,
                    originalGender: 'female',
                    isHuman: false,
                    currentBodyId: 3
                }
            ];

            // Reset stats
            gameState.stats = {
                turns: 0,
                cardsDrawn: 0,
                specialCardsPlayed: 0,
                bodySwaps: 0
            };

            // Clear chat
            chatArea.innerHTML = '';
            hideCounterOptions();
            hideUnoChallengeOptions();
        }

        // Simulate AI turn
        function simulateAITurn() {
            const aiPlayer = gameState.players[gameState.currentPlayer];
            const difficulty = gameState.settings.aiDifficulty;

            // First, check if any other player has one card but didn't call UNO
            const playersWithOneCard = gameState.players.filter(p =>
                p.id !== gameState.currentPlayer &&
                p.cards.length === 1 &&
                !gameState.unoCalled
            );

            if (playersWithOneCard.length > 0) {
                // AI challenges UNO based on difficulty
                let challengeProbability = 0.3; // Easy
                if (difficulty === 'medium') challengeProbability = 0.6;
                if (difficulty === 'hard') challengeProbability = 0.9;

                if (Math.random() < challengeProbability) {
                    const targetPlayer = playersWithOneCard[Math.floor(Math.random() * playersWithOneCard.length)];
                    addUnoChallenge(aiPlayer.name, targetPlayer.name);
                }
            }

            // Then proceed with normal turn
            // Find playable cards
            const playableCards = aiPlayer.cards.map((card, index) => ({ card, index }))
                .filter(({ card }) => canPlayCard(card));

            if (playableCards.length > 0) {
                // AI plays a card based on strategy
                let cardToPlay;

                if (difficulty === 'easy') {
                    // Easy AI plays randomly
                    cardToPlay = playableCards[Math.floor(Math.random() * playableCards.length)];
                } else if (difficulty === 'medium') {
                    // Medium AI prefers action cards
                    const actionCards = playableCards.filter(({ card }) => card.type !== 'number');
                    cardToPlay = actionCards.length > 0 ?
                        actionCards[Math.floor(Math.random() * actionCards.length)] :
                        playableCards[Math.floor(Math.random() * playableCards.length)];
                } else {
                    // Hard AI uses more strategy
                    const actionCards = playableCards.filter(({ card }) => card.type !== 'number');
                    const drawCards = playableCards.filter(({ card }) => card.type === 'draw2' || card.type === 'wild4');
                    const swapCards = playableCards.filter(({ card }) => card.type === 'bodyswap');

                    // Prefer draw cards to put pressure on opponents
                    if (drawCards.length > 0) {
                        cardToPlay = drawCards[Math.floor(Math.random() * drawCards.length)];
                    }
                    // Then prefer swap cards for strategic advantage
                    else if (swapCards.length > 0) {
                        cardToPlay = swapCards[Math.floor(Math.random() * swapCards.length)];
                    }
                    // Then other action cards
                    else if (actionCards.length > 0) {
                        cardToPlay = actionCards[Math.floor(Math.random() * actionCards.length)];
                    }
                    // Finally, number cards
                    else {
                        cardToPlay = playableCards[Math.floor(Math.random() * playableCards.length)];
                    }
                }

                playCard(cardToPlay.index, true);
            } else {
                // AI draws a card
                drawCard();
            }
        }

        // Show UNO challenge options
        function showUnoChallengeOptions() {
            unoChallengeSection.style.display = 'flex';
            enablePlayerControls();
        }

        // Hide UNO challenge options
        function hideUnoChallengeOptions() {
            unoChallengeSection.style.display = 'none';
        }

        // Handle UNO challenge
        function challengeUno() {
            const targetPlayer = gameState.players[gameState.unoChallengeState.targetPlayer];
            const challenger = gameState.players[gameState.currentPlayer];

            // FIX: Check if UNO was already called - if yes, challenge fails
            if (gameState.unoCalled) {
                // UNO was already called - invalid challenge
                addChatMessage(challenger.name, `falsely challenged ${targetPlayer.name} who already called UNO!`);
                showNotification(`${challenger.name} falsely challenged ${targetPlayer.name}! ${challenger.name} draws 2 penalty cards.`, "warning");

                // Penalty for false UNO call - challenger draws 2 cards
                for (let i = 0; i < 2; i++) {
                    if (gameState.deck.length === 0) {
                        const topCard = gameState.discardPile.pop();
                        gameState.deck = [...gameState.discardPile];
                        gameState.discardPile = [topCard];
                        shuffleDeck();
                    }
                    challenger.cards.push(gameState.deck.pop());
                }
            }
            // Check if target has exactly 1 card AND didn't call UNO
            else if (targetPlayer.cards.length === 1 && !gameState.unoCalled) {
                // Valid challenge - target draws 2 penalty cards
                addChatMessage(challenger.name, `successfully challenged ${targetPlayer.name} for not calling UNO!`);
                showNotification(`${challenger.name} successfully challenged ${targetPlayer.name}! ${targetPlayer.name} draws 2 penalty cards.`, "success");

                // Draw 2 penalty cards
                for (let i = 0; i < 2; i++) {
                    if (gameState.deck.length === 0) {
                        const topCard = gameState.discardPile.pop();
                        gameState.deck = [...gameState.discardPile];
                        gameState.discardPile = [topCard];
                        shuffleDeck();
                    }
                    targetPlayer.cards.push(gameState.deck.pop());
                }

                gameState.unoCalled = true; // Mark as called to prevent multiple challenges
            } else {
                // Invalid challenge - target doesn't have exactly 1 card
                addChatMessage(challenger.name, `falsely challenged ${targetPlayer.name}!`);
                showNotification(`${challenger.name} falsely challenged ${targetPlayer.name}! ${challenger.name} draws 2 penalty cards.`, "warning");

                // Penalty for false UNO call - challenger draws 2 cards
                for (let i = 0; i < 2; i++) {
                    if (gameState.deck.length === 0) {
                        const topCard = gameState.discardPile.pop();
                        gameState.deck = [...gameState.discardPile];
                        gameState.discardPile = [topCard];
                        shuffleDeck();
                    }
                    challenger.cards.push(gameState.deck.pop());
                }
            }

            // Reset challenge state
            gameState.unoChallengeState.active = false;
            hideUnoChallengeOptions();

            // Continue with the game
            completeTurnChange();
        }

        // Decline UNO challenge
        function declineUnoChallenge() {
            const targetPlayer = gameState.players[gameState.unoChallengeState.targetPlayer];
            addChatMessage("System", `No one challenged ${targetPlayer.name} for not calling UNO!`);

            // Reset challenge state
            gameState.unoChallengeState.active = false;
            hideUnoChallengeOptions();

            // Continue with the game
            completeTurnChange();
        }

        // Handle AI UNO challenge
        function handleAIUnoChallenge() {
            const targetPlayer = gameState.players[gameState.unoChallengeState.targetPlayer];

            // FIX: Don't challenge if UNO was already called
            if (gameState.unoCalled) {
                declineUnoChallenge();
                return;
            }

            const possibleChallengers = gameState.players.filter(p =>
                p.id !== gameState.unoChallengeState.targetPlayer &&
                !p.isHuman
            );

            if (possibleChallengers.length > 0) {
                // AI decides whether to challenge based on difficulty
                const difficulty = gameState.settings.aiDifficulty;
                let challengeProbability = 0.3; // Easy
                if (difficulty === 'medium') challengeProbability = 0.6;
                if (difficulty === 'hard') challengeProbability = 0.9;

                if (Math.random() < challengeProbability) {
                    const challenger = possibleChallengers[Math.floor(Math.random() * possibleChallengers.length)];
                    addUnoChallenge(challenger.name, targetPlayer.name);
                } else {
                    declineUnoChallenge();
                }
            } else {
                declineUnoChallenge();
            }
        }

        // UNO challenge function
        function addUnoChallenge(playerName, targetPlayerName) {
            addChatMessage(playerName, `calls UNO on ${targetPlayerName}!`);

            const targetPlayer = gameState.players.find(p => p.name.replace(' (You)', '') === targetPlayerName.replace(' (You)', ''));
            const challenger = gameState.players.find(p => p.name.replace(' (You)', '') === playerName.replace(' (You)', ''));

            if (targetPlayer && challenger) {
                // FIX: Check if UNO was already called first
                if (gameState.unoCalled) {
                    // False call - UNO was already called
                    addChatMessage("System", `False UNO call! ${targetPlayerName} already called UNO. ${playerName} draws 2 cards!`);

                    // Penalty for false UNO call - challenger draws 2 cards
                    for (let i = 0; i < 2; i++) {
                        if (gameState.deck.length === 0) {
                            const topCard = gameState.discardPile.pop();
                            gameState.deck = [...gameState.discardPile];
                            gameState.discardPile = [topCard];
                            shuffleDeck();
                        }
                        challenger.cards.push(gameState.deck.pop());
                    }
                }
                // Check if target has exactly 1 card AND didn't call UNO
                else if (targetPlayer.cards.length === 1 && !gameState.unoCalled) {
                    // Valid challenge - target draws 2 penalty cards
                    addChatMessage("System", `${playerName} successfully challenged ${targetPlayerName}! ${targetPlayerName} draws 2 penalty cards.`);

                    // Draw 2 penalty cards
                    for (let i = 0; i < 2; i++) {
                        if (gameState.deck.length === 0) {
                            const topCard = gameState.discardPile.pop();
                            gameState.deck = [...gameState.discardPile];
                            gameState.discardPile = [topCard];
                            shuffleDeck();
                        }
                        targetPlayer.cards.push(gameState.deck.pop());
                    }

                    gameState.unoCalled = true; // Mark as called to prevent multiple challenges

                    // Update display if it's the human player
                    if (targetPlayer.isHuman) {
                        updatePlayerHand();
                        enablePlayerControls();
                    }

                } else if (targetPlayer.cards.length !== 1) {
                    // False call - target doesn't have exactly 1 card
                    addChatMessage("System", `False UNO call! ${targetPlayerName} has ${targetPlayer.cards.length} cards. ${playerName} draws 2 cards!`);

                    // Penalty for false UNO call - challenger draws 2 cards
                    for (let i = 0; i < 2; i++) {
                        if (gameState.deck.length === 0) {
                            const topCard = gameState.discardPile.pop();
                            gameState.deck = [...gameState.discardPile];
                            gameState.discardPile = [topCard];
                            shuffleDeck();
                        }
                        challenger.cards.push(gameState.deck.pop());
                    }
                }
            }

            // Reset challenge state
            gameState.unoChallengeState.active = false;
        }

        // Update stats display
        function updateStats() {
            document.getElementById('stat-turns').textContent = gameState.stats.turns;
            document.getElementById('stat-cards-drawn').textContent = gameState.stats.cardsDrawn;
            document.getElementById('stat-special-cards').textContent = gameState.stats.specialCardsPlayed;
            document.getElementById('stat-body-swaps').textContent = gameState.stats.bodySwaps;
        }

        // Load settings from localStorage
        function loadSettings() {
            const savedSettings = localStorage.getItem('unoGameSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                gameState.settings = { ...gameState.settings, ...settings };

                // Update UI to match loaded settings
                enableSound.checked = gameState.settings.soundEnabled;
                enableAnimations.checked = gameState.settings.animationsEnabled;
                enableChat.checked = gameState.settings.chatEnabled;
                adultMessagesCheckbox.checked = gameState.settings.adultMessages;
                aiDifficulty.value = gameState.settings.aiDifficulty;

                // Apply settings
                chatArea.style.display = gameState.settings.chatEnabled ? 'block' : 'none';
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            localStorage.setItem('unoGameSettings', JSON.stringify(gameState.settings));
        }

        // Initialize the game
        initGame();
    });
</script>
</body>

</html>
